"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = run;
const commander_1 = require("commander");
const clock_1 = require("../src/clock");
const encoder_1 = require("../src/encoder");
const registry_1 = require("../src/registry");
const server_1 = require("./src/server");
const simulator_1 = require("./src/simulator");
const worker_1 = require("./src/worker");
// Function definition
function* fibLfi(ctx, n) {
    if (n <= 1) {
        return n;
    }
    const p1 = yield ctx.beginRun(fibLfi, n - 1, ctx.options({ id: `fibLfi-${n - 1}` }));
    const p2 = yield ctx.beginRun(fibLfi, n - 2, ctx.options({ id: `fibLfi-${n - 2}` }));
    return (yield p1) + (yield p2);
}
function* fibRfi(ctx, n) {
    if (n <= 1) {
        return n;
    }
    const p1 = yield ctx.beginRpc("fibRfi", n - 1, ctx.options({ id: `fibRfi-${n - 1}` }));
    const p2 = yield ctx.beginRpc("fibRfi", n - 2, ctx.options({ id: `fibRfi-${n - 2}` }));
    return (yield p1) + (yield p2);
}
function* fibLfc(ctx, n) {
    if (n <= 1) {
        return n;
    }
    const v1 = yield ctx.run(fibLfc, n - 1, ctx.options({ id: `fibLfc-${n - 1}` }));
    const v2 = yield ctx.run(fibLfc, n - 2, ctx.options({ id: `fibLfc-${n - 2}` }));
    return v1 + v2;
}
function* fibRfc(ctx, n) {
    if (n <= 1) {
        return n;
    }
    const v1 = yield ctx.rpc("fibRfc", n - 1, ctx.options({ id: `fibRfc-${n - 1}` }));
    const v2 = yield ctx.rpc("fibRfc", n - 2, ctx.options({ id: `fibRfc-${n - 2}` }));
    return v1 + v2;
}
function* foo(ctx) {
    const p1 = yield ctx.beginRun(bar);
    const p2 = yield ctx.beginRpc("bar");
    yield ctx.beginRun(bar);
    yield ctx.beginRpc("bar");
    yield ctx.run(bar);
    yield ctx.rpc("bar");
    return [yield p1, yield p2];
}
function* bar(ctx) {
    const p1 = yield ctx.beginRun(baz);
    const p2 = yield ctx.beginRpc("baz");
    yield ctx.beginRun(baz);
    yield ctx.beginRpc("baz");
    yield ctx.run(baz);
    yield ctx.rpc("baz");
    return [yield p1, yield p2];
}
function* baz(ctx) {
    return "baz";
}
const availableFuncs = { fibLfi: fibLfi, fibRfi: fibRfi, fibLfc: fibLfc, fibRfc: fibRfc, foo: foo, bar: bar, baz: baz };
// CLI
const program = new commander_1.Command();
program
    .name("sim")
    .description("Run the simulator with a given seed and steps")
    .option("--seed <number>", "Random seed", (value) => {
    const n = Number.parseInt(value, 10);
    if (Number.isNaN(n)) {
        throw new Error(`Invalid seed: ${value}`);
    }
    return n;
}, 0)
    .option("--steps <number>", "Number of steps", (value) => {
    const n = Number.parseInt(value, 10);
    if (Number.isNaN(n) || n < 0) {
        throw new Error(`Invalid steps: ${value}`);
    }
    return n;
}, 10_000)
    .option("--func <name>", `Function to run (optional). Choices: ${Object.keys(availableFuncs).join(", ")}`, (value) => {
    if (!Object.keys(availableFuncs).includes(value)) {
        throw new Error(`Invalid function: ${value}. Allowed: ${Object.keys(availableFuncs).join(", ")}`);
    }
    return value;
})
    .option("--randomDelay <number>", "Random delay probability (0-1)", (value) => {
    const n = Number.parseFloat(value);
    if (Number.isNaN(n) || n < 0 || n > 1) {
        throw new Error(`Invalid randomDelay: ${value} (must be 0–1)`);
    }
    return n;
})
    .option("--dropProb <number>", "Drop probability (0-1)", (value) => {
    const n = Number.parseFloat(value);
    if (Number.isNaN(n) || n < 0 || n > 1) {
        throw new Error(`Invalid dropProb: ${value} (must be 0–1)`);
    }
    return n;
})
    .option("--duplProb <number>", "Duplicate probability (0-1)", (value) => {
    const n = Number.parseFloat(value);
    if (Number.isNaN(n) || n < 0 || n > 1) {
        throw new Error(`Invalid duplProb: ${value} (must be 0–1)`);
    }
    return n;
})
    .option("--charFlipProb <number>", "Character flip prob (0-1)", (value) => {
    const n = Number.parseFloat(value);
    if (Number.isNaN(n) || n < 0 || n > 1) {
        throw new Error(`Invalid charFlipProb: ${value} (must be 0–1)`);
    }
    return n;
})
    .option("--deactivateProb <number>", "Deactivate probability (0-1)", (value) => {
    const n = Number.parseFloat(value);
    if (Number.isNaN(n) || n < 0 || n > 1) {
        throw new Error(`Invalid deactivateProb: ${value} (must be 0–1)`);
    }
    return n;
})
    .option("--activateProb <number>", "Activate probability (0-1)", (value) => {
    const n = Number.parseFloat(value);
    if (Number.isNaN(n) || n < 0 || n > 1) {
        throw new Error(`Invalid activateProb: ${value} (must be 0–1)`);
    }
    return n;
});
program.parse(process.argv);
const options = program.opts();
function run(options) {
    // effectively disable queueMicrotask
    const rnd = new simulator_1.Random(options.seed);
    const sim = new simulator_1.Simulator(rnd, {
        randomDelay: options.randomDelay ?? rnd.random(0.5),
        dropProb: options.dropProb ?? rnd.random(0.5),
        duplProb: options.duplProb ?? rnd.random(0.5),
        deactivateProb: options.deactivateProb ?? rnd.random(0.01),
        activateProb: options.activateProb ?? rnd.random(0.5),
    });
    const clock = new clock_1.StepClock();
    const encoder = new encoder_1.JsonEncoder();
    const registry = new registry_1.Registry();
    for (const [name, func] of Object.entries(availableFuncs)) {
        registry.add(func, name);
    }
    // server
    sim.register(new server_1.ServerProcess(clock, "server"));
    // workers
    for (let i = 1; i <= 3; i++) {
        sim.register(new worker_1.WorkerProcess(rnd, clock, encoder, registry, { charFlipProb: options.charFlipProb ?? rnd.random(0.05) }, `worker-${i}`, "default"));
    }
    sim.repeat(1, () => {
        const i = sim.step - 1;
        const useExplicit = options.func && i === 0;
        const funcName = useExplicit
            ? options.func
            : Object.keys(availableFuncs)[rnd.randint(0, Object.keys(availableFuncs).length - 1)];
        if (!options.func || i === 0) {
            const id = `${funcName}-${i}`;
            const timeout = rnd.randint(0, options.steps);
            let msg;
            switch (funcName) {
                case "fibLfi":
                case "fibLfc":
                case "fibRfi":
                case "fibRfc": {
                    msg = new simulator_1.Message((0, simulator_1.unicast)("environment"), (0, simulator_1.unicast)("server"), {
                        kind: "createPromise",
                        id,
                        timeout,
                        iKey: id,
                        tags: { "resonate:invoke": "local://any@default" },
                        param: encoder.encode({ func: funcName, args: [rnd.randint(0, 20)], version: 1 }),
                    }, { requ: true, correlationId: i });
                    break;
                }
                case "foo":
                case "bar":
                case "baz": {
                    msg = new simulator_1.Message((0, simulator_1.unicast)("environment"), (0, simulator_1.unicast)("server"), {
                        kind: "createPromise",
                        id,
                        timeout,
                        iKey: id,
                        tags: { "resonate:invoke": "local://any@default" },
                        param: encoder.encode({ func: funcName, args: [], version: 1 }),
                    }, { requ: true, correlationId: i });
                    break;
                }
                default:
                    throw new Error(`unknown function name: ${funcName}`);
            }
            sim.send(msg);
        }
    });
    sim.exec(options.steps);
    console.log("[outbox]: ", sim.outbox);
}
if (require.main === module) {
    run(options);
}
//# sourceMappingURL=main.js.map