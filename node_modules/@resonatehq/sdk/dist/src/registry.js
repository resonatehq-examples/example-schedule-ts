"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Registry = void 0;
const exceptions_1 = __importDefault(require("./exceptions"));
class Registry {
    forward = new Map();
    reverse = new Map();
    add(func, name = "", version = 1) {
        // version must be greater than zero
        if (!(version > 0)) {
            throw exceptions_1.default.REGISTRY_VERSION_INVALID(version);
        }
        // function must have a name
        if (name === "" && func.name === "") {
            throw exceptions_1.default.REGISTRY_NAME_REQUIRED();
        }
        const funcName = name || func.name;
        // function must not already be registered
        if (this.get(funcName, version)) {
            throw exceptions_1.default.REGISTRY_FUNCTION_ALREADY_REGISTERED(funcName, version);
        }
        if (this.get(func, version)) {
            throw exceptions_1.default.REGISTRY_FUNCTION_ALREADY_REGISTERED(func.name, version, this.get(func, version)?.name);
        }
        const forward = this.forward.get(funcName) ?? {};
        const reverse = this.reverse.get(func) ?? {};
        forward[version] = reverse[version] = { name: funcName, func, version };
        this.forward.set(funcName, forward);
        this.reverse.set(func, reverse);
    }
    get(func, version = 0) {
        const registry = typeof func === "string" ? this.forward.get(func) : this.reverse.get(func);
        return registry?.[version > 0 ? version : this.latest(registry)];
    }
    latest(registry) {
        return Math.max(...(Object.keys(registry ?? {}).map(Number) || [1]));
    }
}
exports.Registry = Registry;
//# sourceMappingURL=registry.js.map