"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HOUR = exports.MIN = exports.SEC = exports.MS = void 0;
exports.assert = assert;
exports.assertDefined = assertDefined;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTaskRecord = isTaskRecord;
exports.isDurablePromiseRecord = isDurablePromiseRecord;
exports.isOptions = isOptions;
exports.isMessageSource = isMessageSource;
exports.splitArgsAndOpts = splitArgsAndOpts;
exports.isUrl = isUrl;
exports.base64Encode = base64Encode;
exports.base64Decode = base64Decode;
exports.semverLessThan = semverLessThan;
exports.getCallerInfo = getCallerInfo;
const options_1 = require("./options");
// time
exports.MS = 1;
exports.SEC = 1000;
exports.MIN = 60 * exports.SEC;
exports.HOUR = 60 * exports.MIN;
// assert
function assert(cond, msg) {
    if (cond)
        return; // Early return if assertion passes
    console.assert(cond, "Assertion Failed: %s", msg);
    console.trace();
    if (typeof process !== "undefined" && process.versions.node) {
        process.exit(1);
    }
}
function assertDefined(val) {
    assert(val !== null && val !== undefined, "value must not be null");
}
function isGeneratorFunction(func) {
    const GeneratorFunction = Object.getPrototypeOf(function* () { }).constructor;
    const AsyncGeneratorFunction = Object.getPrototypeOf(async function* () { }).constructor;
    return func instanceof GeneratorFunction || func instanceof AsyncGeneratorFunction;
}
// guards
function isTaskRecord(obj) {
    return (typeof obj === "object" &&
        obj !== null &&
        typeof obj.id === "string" &&
        typeof obj.rootPromiseId === "string" &&
        typeof obj.counter === "number" &&
        typeof obj.timeout === "number" &&
        (obj.processId === undefined || typeof obj.processId === "string") &&
        (obj.createdOn === undefined || typeof obj.createdOn === "number") &&
        (obj.completedOn === undefined || typeof obj.completedOn === "number"));
}
function isDurablePromiseRecord(obj) {
    return (typeof obj === "object" &&
        obj !== null &&
        typeof obj.id === "string" &&
        typeof obj.timeout === "number" &&
        typeof obj.param !== "undefined" && // allow any type
        typeof obj.value !== "undefined" && // allow any type
        typeof obj.tags === "object" &&
        obj.tags !== null &&
        !Array.isArray(obj.tags) &&
        Object.values(obj.tags).every((v) => typeof v === "string") &&
        ["PENDING", "RESOLVED", "REJECTED", "REJECTED_CANCELED", "REJECTED_TIMEDOUT"].includes(obj.state) &&
        (typeof obj.iKeyForCreate === "undefined" || typeof obj.iKeyForCreate === "string") &&
        (typeof obj.iKeyForComplete === "undefined" || typeof obj.iKeyForComplete === "string") &&
        (typeof obj.createdOn === "undefined" || typeof obj.createdOn === "number") &&
        (typeof obj.completedOn === "undefined" || typeof obj.completedOn === "number"));
}
function isOptions(obj) {
    return typeof obj === "object" && obj !== null && options_1.RESONATE_OPTIONS in obj;
}
function isMessageSource(v) {
    return typeof v === "object" && v !== null && "recv" in v && typeof v.recv === "function";
}
// helpers
function splitArgsAndOpts(args, defaults) {
    const opts = isOptions(args.at(-1)) ? args.pop() : {};
    return [args, { ...defaults, ...opts }];
}
function isUrl(str) {
    try {
        new URL(str);
        return true;
    }
    catch {
        return false;
    }
}
function base64Encode(str) {
    const bytes = new TextEncoder().encode(str);
    return btoa(String.fromCharCode(...bytes));
}
function base64Decode(str) {
    const bytes = Uint8Array.from(atob(str), (c) => c.charCodeAt(0));
    const jsonStr = new TextDecoder().decode(bytes);
    return jsonStr;
}
function semverLessThan(a, b) {
    const [aMajor, aMinor, aPatch] = a.split(".").map((x) => Number.parseInt(x, 10));
    const [bMajor, bMinor, bPatch] = b.split(".").map((x) => Number.parseInt(x, 10));
    if (aMajor !== bMajor)
        return aMajor < bMajor;
    if (aMinor !== bMinor)
        return aMinor < bMinor;
    return aPatch < bPatch;
}
function getCallerInfo() {
    const err = new Error();
    if (!err.stack)
        return "";
    const stack = err.stack.split("\n");
    // stack[0] is "Error"
    // stack[1] is this function (getCallerInfo)
    // stack[2] is the caller of this function
    // stack[3] is the info we want
    const callerLine = stack?.[3];
    return callerLine.trim();
}
//# sourceMappingURL=util.js.map