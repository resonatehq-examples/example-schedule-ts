import type { Context, DIE, Future, LFC, LFI, RFC, RFI } from "./context";
import type { Options } from "./options";
export type Func = (ctx: Context, ...args: any[]) => any;
export type Params<F> = F extends (ctx: Context, ...args: infer P) => any ? P : never;
export type ParamsWithOptions<F> = [...Params<F>, Options?];
export type Yieldable<T = any> = LFI<T> | LFC<T> | RFI<T> | RFC<T> | Future<T> | DIE;
export type Return<T> = T extends (...args: any[]) => Generator<infer __, infer R, infer _> ? R : T extends (...args: any[]) => infer R ? Awaited<R> : never;
export type Result<T> = Ok<T> | Ko;
type Ok<T> = {
    success: true;
    value: T;
};
type Ko = {
    success: false;
    error: any;
};
export declare function ok<T>(value: T): Result<T>;
export declare function ko(error: any): Result<any>;
export type Callback<T> = {
    (err: false, res: T): void;
    (err: true, res?: undefined): void;
};
export interface Value<T> {
    headers?: Record<string, string>;
    data?: T;
}
export {};
//# sourceMappingURL=types.d.ts.map