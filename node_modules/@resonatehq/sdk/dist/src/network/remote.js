"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PollMessageSource = exports.HttpNetwork = void 0;
const eventsource_1 = require("eventsource");
const exceptions_1 = __importStar(require("../exceptions"));
const util = __importStar(require("../util"));
class HttpNetwork {
    EXCPECTED_RESONATE_VERSION = "0.7.15";
    url;
    timeout;
    headers;
    verbose;
    constructor({ url = "http://localhost:8001", timeout = 30 * util.SEC, headers = {}, auth = undefined, token = undefined, verbose = false, }) {
        this.url = url;
        this.timeout = timeout;
        this.verbose = verbose;
        this.headers = { "Content-Type": "application/json", ...headers };
        if (token) {
            this.headers.Authorization = `Bearer ${token}`;
        }
        else if (auth) {
            this.headers.Authorization = `Basic ${util.base64Encode(`${auth.username}:${auth.password}`)}`;
        }
    }
    send(req, callback, headers = {}, retryForever = false) {
        const retryPolicy = retryForever ? { retries: Number.MAX_SAFE_INTEGER, delay: 1000 } : { retries: 0 };
        this.handleRequest(req, headers, retryPolicy).then((res) => {
            util.assert(res.kind === req.kind, "res kind must match req kind");
            callback(undefined, res);
        }, (err) => {
            callback(err);
        });
    }
    start() { }
    stop() { }
    async handleRequest(req, headers, retryPolicy = {}) {
        switch (req.kind) {
            case "createPromise":
                return this.createPromise(req, headers, retryPolicy);
            case "createPromiseAndTask":
                return this.createPromiseAndTask(req, headers, retryPolicy);
            case "readPromise":
                return this.readPromise(req, retryPolicy);
            case "completePromise":
                return this.completePromise(req, retryPolicy);
            case "createCallback":
                return this.createCallback(req, headers, retryPolicy);
            case "createSubscription":
                return this.createSubscription(req, retryPolicy);
            case "createSchedule":
                return this.createSchedule(req, retryPolicy);
            case "readSchedule":
                return this.readSchedule(req, retryPolicy);
            case "deleteSchedule":
                return this.deleteSchedule(req, retryPolicy);
            case "claimTask":
                return this.claimTask(req, retryPolicy);
            case "completeTask":
                return this.completeTask(req, retryPolicy);
            case "dropTask":
                return this.dropTask(req, retryPolicy);
            case "heartbeatTasks":
                return this.heartbeatTasks(req, retryPolicy);
            case "searchPromises":
                return this.searchPromises(req, retryPolicy);
            case "searchSchedules":
                return this.searchSchedules(req, retryPolicy);
        }
    }
    async createPromise(req, headers, retryPolicy = {}) {
        if (req.iKey)
            headers["idempotency-key"] = req.iKey;
        if (req.strict !== undefined)
            headers.strict = req.strict.toString();
        const res = await this.fetch("/promises", {
            method: "POST",
            headers,
            body: JSON.stringify({
                id: req.id,
                timeout: req.timeout,
                param: req.param,
                tags: req.tags,
            }),
        }, retryPolicy);
        const promise = mapPromiseDtoToRecord((await res.json()));
        return { kind: "createPromise", promise };
    }
    async createPromiseAndTask(req, headers, retryPolicy = {}) {
        if (req.iKey)
            headers["idempotency-key"] = req.iKey;
        if (req.strict !== undefined)
            headers.strict = req.strict.toString();
        const res = await this.fetch("/promises/task", {
            method: "POST",
            headers,
            body: JSON.stringify({
                promise: {
                    id: req.promise.id,
                    timeout: req.promise.timeout,
                    param: req.promise.param,
                    tags: req.promise.tags,
                },
                task: {
                    processId: req.task.processId,
                    ttl: req.task.ttl,
                },
            }),
        }, retryPolicy);
        const data = (await res.json());
        return {
            kind: "createPromiseAndTask",
            promise: mapPromiseDtoToRecord(data.promise),
            task: data.task ? this.mapTaskDtoToRecord(data.task) : undefined,
        };
    }
    async readPromise(req, retryPolicy = {}) {
        const res = await this.fetch(`/promises/${encodeURIComponent(req.id)}`, { method: "GET" }, retryPolicy);
        const promise = mapPromiseDtoToRecord((await res.json()));
        return { kind: "readPromise", promise };
    }
    async completePromise(req, retryPolicy = {}) {
        const headers = {};
        if (req.iKey)
            headers["idempotency-key"] = req.iKey;
        if (req.strict !== undefined)
            headers.strict = req.strict.toString();
        const res = await this.fetch(`/promises/${encodeURIComponent(req.id)}`, {
            method: "PATCH",
            headers,
            body: JSON.stringify({
                state: req.state.toUpperCase(),
                value: req.value,
            }),
        }, retryPolicy);
        const promise = mapPromiseDtoToRecord((await res.json()));
        return { kind: "completePromise", promise };
    }
    async createCallback(req, headers, retryPolicy = {}) {
        const res = await this.fetch(`/promises/callback/${encodeURIComponent(req.promiseId)}`, {
            method: "POST",
            headers,
            body: JSON.stringify({
                rootPromiseId: req.rootPromiseId,
                timeout: req.timeout,
                recv: req.recv,
            }),
        }, retryPolicy);
        const data = (await res.json());
        return {
            kind: "createCallback",
            callback: data.callback ? this.mapCallbackDtoToRecord(data.callback) : undefined,
            promise: mapPromiseDtoToRecord(data.promise),
        };
    }
    async createSubscription(req, retryPolicy = {}) {
        const body = {
            id: req.id,
            timeout: req.timeout,
            recv: req.recv,
        };
        const res = await this.fetch(`/promises/subscribe/${encodeURIComponent(req.promiseId)}`, {
            method: "POST",
            body: JSON.stringify(body),
        }, retryPolicy);
        const data = (await res.json());
        return {
            kind: "createSubscription",
            callback: data.callback ? this.mapCallbackDtoToRecord(data.callback) : undefined,
            promise: mapPromiseDtoToRecord(data.promise),
        };
    }
    async createSchedule(req, retryPolicy = {}) {
        const headers = {};
        if (req.iKey)
            headers["idempotency-key"] = req.iKey;
        const res = await this.fetch("/schedules", {
            method: "POST",
            headers,
            body: JSON.stringify({
                id: req.id,
                description: req.description,
                cron: req.cron,
                tags: req.tags,
                promiseId: req.promiseId,
                promiseTimeout: req.promiseTimeout,
                promiseParam: req.promiseParam,
                promiseTags: req.promiseTags,
            }),
        }, retryPolicy);
        return {
            kind: "createSchedule",
            schedule: this.mapScheduleDtoToRecord((await res.json())),
        };
    }
    async readSchedule(req, retryPolicy = {}) {
        const res = await this.fetch(`/schedules/${encodeURIComponent(req.id)}`, { method: "GET" }, retryPolicy);
        return {
            kind: "readSchedule",
            schedule: this.mapScheduleDtoToRecord((await res.json())),
        };
    }
    async deleteSchedule(req, retryPolicy = {}) {
        await this.fetch(`/schedules/${encodeURIComponent(req.id)}`, { method: "DELETE" }, retryPolicy);
        return { kind: "deleteSchedule" };
    }
    async claimTask(req, retryPolicy = {}) {
        const res = await this.fetch("/tasks/claim", {
            method: "POST",
            body: JSON.stringify({
                id: req.id,
                counter: req.counter,
                processId: req.processId,
                ttl: req.ttl,
            }),
        }, retryPolicy);
        const message = (await res.json());
        if (message.type !== "invoke" && message.type !== "resume") {
            throw new Error(`Unknown message type: ${message.type}`);
        }
        return {
            kind: "claimTask",
            message: {
                kind: message.type,
                promises: {
                    root: message.promises.root
                        ? {
                            id: message.promises.root.id,
                            data: mapPromiseDtoToRecord(message.promises.root.data),
                        }
                        : undefined,
                    leaf: message.promises.leaf
                        ? {
                            id: message.promises.leaf.id,
                            data: mapPromiseDtoToRecord(message.promises.leaf.data),
                        }
                        : undefined,
                },
            },
        };
    }
    async completeTask(req, retryPolicy = {}) {
        const res = await this.fetch("/tasks/complete", {
            method: "POST",
            body: JSON.stringify({
                id: req.id,
                counter: req.counter,
            }),
        }, retryPolicy);
        return {
            kind: "completeTask",
            task: this.mapTaskDtoToRecord((await res.json())),
        };
    }
    async dropTask(req, retryPolicy = {}) {
        await this.fetch("/tasks/drop", {
            method: "POST",
            body: JSON.stringify({
                id: req.id,
                counter: req.counter,
            }),
        }, retryPolicy);
        return { kind: "dropTask" };
    }
    async heartbeatTasks(req, retryPolicy = {}) {
        const res = await this.fetch("/tasks/heartbeat", {
            method: "POST",
            body: JSON.stringify({
                processId: req.processId,
            }),
        }, retryPolicy);
        const data = (await res.json());
        return {
            kind: "heartbeatTasks",
            tasksAffected: data.tasksAffected,
        };
    }
    async searchPromises(req, retryPolicy = {}) {
        const params = new URLSearchParams({ id: req.id });
        if (req.state)
            params.append("state", req.state);
        if (req.limit)
            params.append("limit", String(req.limit));
        if (req.cursor)
            params.append("cursor", req.cursor);
        const res = await this.fetch(`/promises?${params.toString()}`, { method: "GET" }, retryPolicy);
        const data = (await res.json());
        return { kind: "searchPromises", promises: data.promises, cursor: data.cursor };
    }
    async searchSchedules(req, retryPolicy = {}) {
        const params = new URLSearchParams({ id: req.id });
        if (req.limit)
            params.append("limit", String(req.limit));
        if (req.cursor)
            params.append("cursor", req.cursor);
        const res = await this.fetch(`/schedules?${params.toString()}`, { method: "GET" }, retryPolicy);
        const data = (await res.json());
        return { kind: "searchSchedules", schedules: data.schedules, cursor: data.cursor };
    }
    async fetch(path, init, { retries = 0, delay = 1000 } = {}) {
        const url = `${this.url}${path}`;
        // add default headers
        init.headers = { ...this.headers, ...init.headers };
        for (let attempt = 0; attempt <= retries; attempt++) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), this.timeout);
            try {
                const res = await fetch(url, { ...init, signal: controller.signal });
                const ver = res.headers.get("Resonate-Version") ?? "0.0.0";
                if (util.semverLessThan(ver, this.EXCPECTED_RESONATE_VERSION)) {
                    console.warn(`Networking. Resonate server ${this.EXCPECTED_RESONATE_VERSION} or newer required (provided ${ver}). Will continue.`);
                }
                if (!res.ok) {
                    const err = (await res
                        .json()
                        .then((r) => r.error)
                        .catch(() => undefined));
                    throw exceptions_1.default.SERVER_ERROR(err ? err.message : res.statusText, res.status >= 500 && res.status < 600, err);
                }
                return res;
            }
            catch (err) {
                if (err instanceof exceptions_1.ResonateError && !err.retriable) {
                    throw err;
                }
                if (attempt >= retries) {
                    throw exceptions_1.default.SERVER_ERROR(String(err));
                }
                console.warn(`Networking. Cannot connect to [${this.url}]. Retrying in ${delay / 1000}s.`);
                if (this.verbose) {
                    console.warn(err);
                }
                // sleep before retrying
                await new Promise((resolve) => setTimeout(resolve, delay));
            }
            finally {
                clearTimeout(timeoutId);
            }
        }
        throw new Error("Fetch error");
    }
    mapScheduleDtoToRecord(schedule) {
        return {
            id: schedule.id,
            description: schedule.description,
            cron: schedule.cron,
            tags: schedule.tags || {},
            promiseId: schedule.promiseId,
            promiseTimeout: schedule.promiseTimeout,
            promiseParam: schedule.promiseParam,
            promiseTags: schedule.promiseTags || {},
            iKey: schedule.idempotencyKey,
            lastRunTime: schedule.lastRunTime,
            nextRunTime: schedule.nextRunTime,
            createdOn: schedule.createdOn,
        };
    }
    mapCallbackDtoToRecord(apiCallback) {
        return {
            id: apiCallback.id,
            promiseId: apiCallback.promiseId,
            timeout: apiCallback.timeout,
            createdOn: apiCallback.createdOn,
        };
    }
    mapTaskDtoToRecord(apiTask) {
        return {
            id: apiTask.id,
            rootPromiseId: apiTask.rootPromiseId,
            counter: apiTask.counter,
            timeout: apiTask.timeout,
            processId: apiTask.processId,
            createdOn: apiTask.createdOn,
            completedOn: apiTask.completedOn,
        };
    }
}
exports.HttpNetwork = HttpNetwork;
class PollMessageSource {
    pid;
    group;
    unicast;
    anycast;
    url;
    headers;
    eventSource;
    subscriptions = { invoke: [], resume: [], notify: [] };
    constructor({ url = "http://localhost:8001", pid = crypto.randomUUID().replace(/-/g, ""), group = "default", auth = undefined, token = undefined, }) {
        this.url = url;
        this.pid = pid;
        this.group = group;
        this.unicast = `poll://uni@${group}/${pid}`;
        this.anycast = `poll://any@${group}/${pid}`;
        this.headers = {};
        if (token) {
            this.headers.Authorization = `Bearer ${token}`;
        }
        else if (auth) {
            this.headers.Authorization = `Basic ${util.base64Encode(`${auth.username}:${auth.password}`)}`;
        }
        this.eventSource = this.connect();
    }
    connect() {
        const url = new URL(`/poll/${encodeURIComponent(this.group)}/${encodeURIComponent(this.pid)}`, `${this.url}`);
        this.eventSource = new eventsource_1.EventSource(url, {
            fetch: (url, init) => fetch(url, {
                ...init,
                headers: {
                    ...init.headers,
                    ...this.headers,
                },
            }),
        });
        this.eventSource.addEventListener("message", (event) => {
            let msg;
            try {
                const data = JSON.parse(event.data);
                if ((data?.type === "invoke" || data?.type === "resume") && util.isTaskRecord(data?.task)) {
                    msg = { type: data.type, task: data.task, headers: data.head ?? {} };
                }
                else if (data?.type === "notify" && util.isDurablePromiseRecord(data?.promise)) {
                    msg = { type: data.type, promise: mapPromiseDtoToRecord(data.promise), headers: data.head ?? {} };
                }
                else {
                    throw new Error("invalid message");
                }
            }
            catch (e) {
                console.warn("Networking. Received invalid message. Will continue.");
                return;
            }
            this.recv(msg);
        });
        this.eventSource.addEventListener("error", () => {
            // some browsers/runtimes may handle automatic reconnect
            // differently, so to ensure consistency close the eventsource
            // and recreate
            this.eventSource.close();
            console.warn(`Networking. Cannot connect to [${this.url}/poll]. Retrying in 5s.`);
            setTimeout(() => this.connect(), 5000);
        });
        return this.eventSource;
    }
    recv(msg) {
        for (const callback of this.subscriptions[msg.type]) {
            callback(msg);
        }
    }
    start() { }
    stop() {
        this.eventSource.close();
    }
    subscribe(type, callback) {
        this.subscriptions[type].push(callback);
    }
    match(target) {
        return `poll://any@${target}`;
    }
}
exports.PollMessageSource = PollMessageSource;
function mapApiStateToInternal(state) {
    switch (state) {
        case "PENDING":
            return "pending";
        case "RESOLVED":
            return "resolved";
        case "REJECTED":
            return "rejected";
        case "REJECTED_CANCELED":
            return "rejected_canceled";
        case "REJECTED_TIMEDOUT":
            return "rejected_timedout";
        default:
            throw new Error(`Unknown API state: ${state}`);
    }
}
function mapPromiseDtoToRecord(promise) {
    return {
        id: promise.id,
        state: mapApiStateToInternal(promise.state),
        timeout: promise.timeout,
        param: promise.param,
        value: promise.value,
        tags: promise.tags || {},
        iKeyForCreate: promise.idempotencyKeyForCreate,
        iKeyForComplete: promise.idempotencyKeyForComplete,
        createdOn: promise.createdOn,
        completedOn: promise.completedOn,
    };
}
//# sourceMappingURL=remote.js.map