"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncProcessor = void 0;
class AsyncProcessor {
    async process(id, ctx, func, done, verbose, span) {
        while (true) {
            let retryIn = null;
            const childSpan = span.startSpan(`${id}::${ctx.info.attempt}`, ctx.clock.now());
            childSpan.setAttribute("attempt", ctx.info.attempt);
            try {
                const data = await func();
                childSpan.setStatus(true);
                done({ success: true, value: data });
                return;
            }
            catch (error) {
                childSpan.setStatus(false, String(error));
                retryIn = ctx.retryPolicy.next(ctx.info.attempt);
                if (retryIn === null) {
                    done({ success: false, error });
                    return;
                }
                // Use the same clock sourced from ctx for consistency
                if (ctx.clock.now() + retryIn >= ctx.info.timeout) {
                    done({ success: false, error });
                    return;
                }
                console.warn(`Runtime. Function '${ctx.func}' failed with '${String(error)}' (retrying in ${retryIn / 1000} secs)`);
                if (verbose) {
                    console.warn(error);
                }
            }
            finally {
                childSpan.end(ctx.clock.now());
            }
            // Ensure a numeric delay for setTimeout; guard against null just in case
            await new Promise((resolve) => setTimeout(resolve, retryIn ?? 0));
            ctx.info.attempt++;
        }
    }
}
exports.AsyncProcessor = AsyncProcessor;
//# sourceMappingURL=processor.js.map