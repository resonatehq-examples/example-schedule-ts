export interface RetryPolicyConstructor {
    readonly type: string;
    new (arg: any): RetryPolicy;
}
export interface RetryPolicy {
    next(attempt: number): number | null;
    encode(): {
        type: string;
        data: any;
    };
}
export declare class Constant implements RetryPolicy {
    static readonly type = "constant";
    private readonly delay;
    private readonly maxRetries;
    constructor({ delay, maxRetries }?: {
        delay?: number;
        maxRetries?: number;
    });
    next(attempt: number): number | null;
    encode(): {
        type: string;
        data: {
            delay: number;
            maxRetries: number;
        };
    };
}
export declare class Exponential implements RetryPolicy {
    static readonly type = "exponential";
    private readonly delay;
    private readonly maxRetries;
    private readonly factor;
    private readonly maxDelay;
    constructor({ delay, factor, maxRetries, maxDelay, }?: {
        delay?: number;
        factor?: number;
        maxRetries?: number;
        maxDelay?: number;
    });
    next(attempt: number): number | null;
    encode(): {
        type: string;
        data: {
            delay: number;
            factor: number;
            maxRetries: number;
            maxDelay: number;
        };
    };
}
export declare class Linear implements RetryPolicy {
    static readonly type = "linear";
    private readonly delay;
    private readonly maxRetries;
    constructor({ delay, maxRetries }?: {
        delay?: number;
        maxRetries?: number;
    });
    next(attempt: number): number | null;
    encode(): {
        type: string;
        data: {
            delay: number;
            maxRetries: number;
        };
    };
}
export declare class Never implements RetryPolicy {
    static readonly type = "never";
    next(attempt: number): number | null;
    encode(): {
        type: string;
        data: {};
    };
}
//# sourceMappingURL=retries.d.ts.map