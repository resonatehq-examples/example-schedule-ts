"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schedules = void 0;
const network_1 = require("../dev/network");
class Schedules {
    network;
    constructor(network = new network_1.LocalNetwork()) {
        this.network = network;
    }
    get(id) {
        return new Promise((resolve, reject) => {
            this.network.send({
                kind: "readSchedule",
                id: id,
            }, (err, res) => {
                if (err) {
                    // TODO: reject with more information
                    reject(Error("not implemented"));
                    return;
                }
                resolve(res.schedule);
            });
        });
    }
    create(id, cron, promiseId, promiseTimeout, { ikey = undefined, description = undefined, tags = undefined, promiseHeaders = undefined, promiseData = undefined, promiseTags = undefined, } = {}) {
        return new Promise((resolve, reject) => {
            this.network.send({
                kind: "createSchedule",
                id: id,
                description: description,
                cron: cron,
                tags: tags,
                promiseId: promiseId,
                promiseTimeout: promiseTimeout,
                promiseParam: { headers: promiseHeaders, data: promiseData },
                promiseTags: promiseTags,
                iKey: ikey,
            }, (err, res) => {
                if (err) {
                    console.log(err);
                    // TODO: reject with more information
                    reject(Error("not implemented"));
                    return;
                }
                resolve(res.schedule);
            });
        });
    }
    delete(id) {
        return new Promise((resolve, reject) => {
            this.network.send({
                kind: "deleteSchedule",
                id: id,
            }, (err) => {
                if (err) {
                    // TODO: reject with more information
                    reject(Error("not implemented"));
                    return;
                }
                resolve();
            });
        });
    }
    async *search(id, { limit = undefined } = {}) {
        let cursor;
        do {
            const res = await new Promise((resolve, reject) => {
                this.network.send({
                    kind: "searchSchedules",
                    id,
                    limit,
                    cursor,
                }, (err, res) => {
                    if (err)
                        return reject(err);
                    resolve(res);
                });
            });
            cursor = res.cursor;
            yield res.schedules;
        } while (cursor !== null && cursor !== undefined);
    }
}
exports.Schedules = Schedules;
//# sourceMappingURL=schedules.js.map