"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Computation = void 0;
const context_1 = require("./context");
const coroutine_1 = require("./coroutine");
const exceptions_1 = __importDefault(require("./exceptions"));
const nursery_1 = require("./nursery");
const processor_1 = require("./processor/processor");
const retries_1 = require("./retries");
const util = __importStar(require("./util"));
class Computation {
    id;
    pid;
    ttl;
    clock;
    unicast;
    anycast;
    network;
    handler;
    retries;
    registry;
    dependencies;
    optsBuilder;
    verbose;
    heartbeat;
    processor;
    span;
    spans;
    seen = new Set();
    processing = false;
    constructor(id, unicast, anycast, pid, ttl, clock, network, handler, retries, registry, heartbeat, dependencies, optsBuilder, verbose, tracer, span, processor) {
        this.id = id;
        this.unicast = unicast;
        this.anycast = anycast;
        this.pid = pid;
        this.ttl = ttl;
        this.clock = clock;
        this.network = network;
        this.handler = handler;
        this.retries = retries;
        this.registry = registry;
        this.heartbeat = heartbeat;
        this.dependencies = dependencies;
        this.optsBuilder = optsBuilder;
        this.verbose = verbose;
        this.processor = processor ?? new processor_1.AsyncProcessor();
        this.span = span;
        this.spans = new Map();
    }
    process(task, done) {
        // If we are already processing there is nothing to do, the
        // caller will be notified via the promise handler
        if (this.processing)
            return done(true);
        this.processing = true;
        const doneProcessing = (err, res) => {
            this.processing = false;
            err ? done(err) : done(err, res);
        };
        switch (task.kind) {
            case "claimed":
                this.processClaimed(task, doneProcessing);
                break;
            case "unclaimed":
                this.handler.claimTask({
                    kind: "claimTask",
                    id: task.task.id,
                    counter: task.task.counter,
                    processId: this.pid,
                    ttl: this.ttl,
                }, (err, promise) => {
                    if (err) {
                        err.log(this.verbose);
                        return doneProcessing(true);
                    }
                    util.assertDefined(promise);
                    this.processClaimed({ kind: "claimed", task: task.task, rootPromise: promise.root, leafPromise: promise.leaf }, doneProcessing);
                });
                break;
        }
    }
    processClaimed({ task, rootPromise }, done) {
        util.assert(task.rootPromiseId === this.id, "task root promise id must match computation id");
        const doneAndDropTaskIfErr = (err, res) => {
            if (err) {
                return this.network.send({ kind: "dropTask", id: task.id, counter: task.counter }, () => {
                    // ignore the drop task response, if the request failed the
                    // task will eventually expire anyways
                    done(true);
                });
            }
            done(false, res);
        };
        if (!isValidData(rootPromise.param?.data)) {
            return doneAndDropTaskIfErr(true);
        }
        const { func, args, retry, version = 1 } = rootPromise.param.data;
        const registered = this.registry.get(func, version);
        // function must be registered
        if (!registered) {
            exceptions_1.default.REGISTRY_FUNCTION_NOT_REGISTERED(func, version).log(this.verbose);
            return doneAndDropTaskIfErr(true);
        }
        if (version !== 0)
            util.assert(version === registered.version, "versions must match");
        util.assert(func === registered.name, "names must match");
        // start heartbeat
        this.heartbeat.start();
        return new nursery_1.Nursery((nursery) => {
            const done = (err, res) => {
                if (err) {
                    return nursery.done(err);
                }
                this.network.send({ kind: "completeTask", id: task.id, counter: task.counter }, (err) => {
                    nursery.done(!!err, res);
                });
            };
            const retryCtor = retry ? this.retries.get(retry.type) : undefined;
            const retryPolicy = retryCtor
                ? new retryCtor(retry?.data)
                : util.isGeneratorFunction(registered.func)
                    ? new retries_1.Never()
                    : new retries_1.Exponential();
            if (retry && !retryCtor) {
                console.warn(`Options. Retry policy '${retry.type}' not found. Will ignore.`);
            }
            const ctx = new context_1.InnerContext({
                id: this.id,
                func: registered.func.name,
                clock: this.clock,
                registry: this.registry,
                dependencies: this.dependencies,
                optsBuilder: this.optsBuilder,
                timeout: rootPromise.timeout,
                version: registered.version,
                retryPolicy: retryPolicy,
                span: this.span,
            });
            if (util.isGeneratorFunction(registered.func)) {
                this.processGenerator(nursery, ctx, registered.func, args, task, done);
            }
            else {
                this.processFunction(this.id, ctx, registered.func, args, (err, promise) => {
                    if (err)
                        return done(true);
                    util.assertDefined(promise);
                    done(false, { kind: "completed", promise });
                });
            }
        }, doneAndDropTaskIfErr);
    }
    processGenerator(nursery, ctx, func, args, task, done) {
        coroutine_1.Coroutine.exec(this.id, this.verbose, ctx, func, args, task, this.handler, this.spans, (err, status) => {
            if (err) {
                return done(err);
            }
            util.assertDefined(status);
            switch (status.type) {
                case "completed":
                    done(false, { kind: "completed", promise: status.promise });
                    break;
                case "suspended":
                    util.assert(status.todo.local.length > 0 || status.todo.remote.length > 0, "must be at least one todo");
                    if (status.todo.local.length > 0) {
                        this.processLocalTodo(nursery, status.todo.local, done);
                    }
                    else if (status.todo.remote.length > 0) {
                        this.processRemoteTodo(nursery, status.todo.remote, status.spans, ctx.info.timeout, done);
                    }
                    break;
            }
        });
    }
    processFunction(id, ctx, func, args, done) {
        this.processor.process(id, ctx, async () => await func(ctx, ...args), (res) => this.handler.completePromise({
            kind: "completePromise",
            id: id,
            state: res.success ? "resolved" : "rejected",
            value: {
                data: res.success ? res.value : res.error,
            },
            iKey: id,
            strict: false,
        }, (err, res) => {
            if (err) {
                err.log(this.verbose);
                return done(true);
            }
            util.assertDefined(res);
            done(false, res);
        }, func.name), this.verbose, ctx.span);
    }
    processLocalTodo(nursery, todo, done) {
        for (const { id, ctx, span, func, args } of todo) {
            if (this.seen.has(id)) {
                continue;
            }
            this.seen.add(id);
            nursery.hold((next) => {
                this.processFunction(id, ctx, func, args, (err) => {
                    span.end(this.clock.now());
                    next();
                    if (err) {
                        this.seen.delete(id);
                        done(err);
                    }
                });
            });
        }
        // once all local todos are submitted we can call continue
        return nursery.cont();
    }
    processRemoteTodo(nursery, todo, spans, timeout, done) {
        nursery.all(todo, ({ id }, done) => this.handler.createCallback({
            kind: "createCallback",
            promiseId: id,
            rootPromiseId: this.id,
            timeout: timeout,
            recv: this.anycast,
        }, (err, res) => {
            if (err) {
                err.log(this.verbose);
                return done(true);
            }
            util.assertDefined(res);
            done(false, res);
        }, this.span.encode()), (err, results) => {
            if (err) {
                for (const span of spans) {
                    span.end(this.clock.now());
                }
                return done(err);
            }
            util.assertDefined(results);
            const callbacks = [];
            for (const res of results) {
                switch (res.kind) {
                    case "promise":
                        nursery.hold((next) => next());
                        return nursery.cont();
                    case "callback":
                        callbacks.push(res.callback);
                        break;
                }
            }
            for (const span of spans) {
                span.end(this.clock.now());
            }
            // once all callbacks are created we can call done
            return done(false, { kind: "suspended", callbacks });
        });
    }
}
exports.Computation = Computation;
// Helper functions
function isValidData(data) {
    if (data === null || typeof data !== "object")
        return false;
    const d = data;
    // func must be a string
    if (typeof d.func !== "string")
        return false;
    // args must be an array
    if (!Array.isArray(d.args))
        return false;
    // retry (if present) must be an object with string `type` and any `data`
    if (d.retry !== undefined) {
        if (d.retry === null || typeof d.retry !== "object" || typeof d.retry.type !== "string" || !("data" in d.retry)) {
            return false;
        }
    }
    // version (if present) must be a number
    if (d.version !== undefined && typeof d.version !== "number") {
        return false;
    }
    return true;
}
//# sourceMappingURL=computation.js.map