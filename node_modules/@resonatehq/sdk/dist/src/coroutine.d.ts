import type { Context, InnerContext } from "./context";
import { Decorator } from "./decorator";
import type { Handler } from "./handler";
import type { DurablePromiseRecord, TaskRecord } from "./network/network";
import type { Span } from "./tracer";
import { type Callback, type Yieldable } from "./types";
export type Suspended = {
    type: "suspended";
    todo: {
        local: LocalTodo[];
        remote: RemoteTodo[];
    };
    spans: Span[];
};
export type Completed = {
    type: "completed";
    promise: DurablePromiseRecord;
};
export interface LocalTodo {
    id: string;
    ctx: InnerContext;
    span: Span;
    func: (ctx: Context, ...args: any[]) => any;
    args: any[];
}
export interface RemoteTodo {
    id: string;
}
export declare class Coroutine<T> {
    private ctx;
    private task;
    private verbose;
    private decorator;
    private handler;
    private spans;
    private readonly depth;
    private readonly queueMicrotaskEveryN;
    constructor(ctx: InnerContext, task: TaskRecord, verbose: boolean, decorator: Decorator<T>, handler: Handler, spans: Map<string, Span>, depth?: number);
    static exec(id: string, verbose: boolean, ctx: InnerContext, func: (ctx: Context, ...args: any[]) => Generator<Yieldable, any, any>, args: any[], task: TaskRecord, handler: Handler, spans: Map<string, Span>, callback: Callback<Suspended | Completed>): void;
    private exec;
}
//# sourceMappingURL=coroutine.d.ts.map