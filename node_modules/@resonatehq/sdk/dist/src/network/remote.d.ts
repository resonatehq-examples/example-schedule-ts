import { ResonateError } from "../exceptions";
import type { Message, MessageSource, Network, Request, ResponseFor } from "./network";
export interface HttpNetworkConfig {
    verbose: boolean;
    url: string;
    auth?: {
        username: string;
        password: string;
    };
    token?: string;
    timeout?: number;
    headers?: Record<string, string>;
}
export type RetryPolicy = {
    retries?: number;
    delay?: number;
};
export declare class HttpNetwork implements Network {
    private EXCPECTED_RESONATE_VERSION;
    private url;
    private timeout;
    private headers;
    private verbose;
    constructor({ url, timeout, headers, auth, token, verbose, }: {
        url?: string;
        timeout?: number;
        headers?: Record<string, string>;
        auth?: {
            username: string;
            password: string;
        };
        token?: string;
        verbose: boolean;
    });
    send<T extends Request>(req: T, callback: (err?: ResonateError, res?: ResponseFor<T>) => void, headers?: Record<string, string>, retryForever?: boolean): void;
    start(): void;
    stop(): void;
    private handleRequest;
    private createPromise;
    private createPromiseAndTask;
    private readPromise;
    private completePromise;
    private createCallback;
    private createSubscription;
    private createSchedule;
    private readSchedule;
    private deleteSchedule;
    private claimTask;
    private completeTask;
    private dropTask;
    private heartbeatTasks;
    private searchPromises;
    private searchSchedules;
    private fetch;
    private mapScheduleDtoToRecord;
    private mapCallbackDtoToRecord;
    private mapTaskDtoToRecord;
}
export declare class PollMessageSource implements MessageSource {
    readonly pid: string;
    readonly group: string;
    readonly unicast: string;
    readonly anycast: string;
    private url;
    private headers;
    private eventSource;
    private subscriptions;
    constructor({ url, pid, group, auth, token, }: {
        url?: string;
        pid?: string;
        group?: string;
        auth?: {
            username: string;
            password: string;
        };
        token?: string;
    });
    private connect;
    recv(msg: Message): void;
    start(): void;
    stop(): void;
    subscribe(type: "invoke" | "resume" | "notify", callback: (msg: Message) => void): void;
    match(target: string): string;
}
//# sourceMappingURL=remote.d.ts.map