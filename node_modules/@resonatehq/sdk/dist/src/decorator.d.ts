import type { ResonateError } from "./exceptions";
import type { CreatePromiseReq } from "./network/network";
import type { RetryPolicy } from "./retries";
import { type Func, type Result, type Yieldable } from "./types";
export type InternalExpr<T> = InternalAsyncL | InternalAsyncR | InternalAwait<T> | InternalReturn<T> | InternalDie;
export type InternalDie = {
    type: "internal.die";
    condition: boolean;
    error: ResonateError;
};
export type InternalAsyncR = {
    type: "internal.async.r";
    id: string;
    mode: "attached" | "detached";
    func: string;
    version: number;
    createReq: CreatePromiseReq<any>;
};
export type InternalAsyncL = {
    type: "internal.async.l";
    id: string;
    func: Func;
    args: any[];
    version: number;
    retryPolicy: RetryPolicy;
    createReq: CreatePromiseReq<any>;
};
export type InternalAwait<T> = {
    type: "internal.await";
    id: string;
    promise: PromisePending | PromiseCompleted<T>;
};
export type InternalReturn<T> = {
    type: "internal.return";
    value: Literal<T>;
};
export type Value<T> = Nothing | Literal<T> | PromisePending | PromiseCompleted<T>;
export type Nothing = {
    type: "internal.nothing";
};
export type Literal<T> = {
    type: "internal.literal";
    value: Result<T>;
};
export type PromisePending = {
    type: "internal.promise";
    state: "pending";
    mode: "attached" | "detached";
    id: string;
};
export type PromiseCompleted<T> = {
    type: "internal.promise";
    state: "completed";
    id: string;
    value: Literal<T>;
};
export declare class Decorator<TRet> {
    private invokes;
    private generator;
    private nextState;
    constructor(generator: Generator<Yieldable, TRet, any>);
    next(value: Value<any>): InternalExpr<any>;
    private toExternal;
    private toInternal;
    private toLiteral;
    private safeGeneratorNext;
}
//# sourceMappingURL=decorator.d.ts.map