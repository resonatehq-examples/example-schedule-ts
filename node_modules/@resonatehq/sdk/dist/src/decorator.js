"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Decorator = void 0;
const context_1 = require("./context");
const types_1 = require("./types");
const util = __importStar(require("./util"));
class Decorator {
    invokes;
    generator;
    nextState = "internal.nothing";
    constructor(generator) {
        this.generator = generator;
        this.invokes = [];
    }
    next(value) {
        // If nextState was set to over, is becasue we shouldn't have been called
        util.assert(value.type === this.nextState, `Generator called wit type "${value.type}" expected "${this.nextState}"`);
        // Handle rfc/lfc by returning an await if the previous invocation was a call
        // if we await an rpc/rfc promise that is not completed the corotine is done and the decorator shouldn't be called again
        if (value.type === "internal.promise" && this.invokes.length > 0) {
            const prevInvoke = this.invokes.at(-1);
            if (prevInvoke.kind === "call") {
                this.invokes.pop();
                this.nextState = value.state === "completed" ? "internal.literal" : "over";
                return {
                    type: "internal.await",
                    id: prevInvoke.id,
                    promise: value,
                };
            }
        }
        const result = this.safeGeneratorNext(this.toExternal(value));
        if (result.done) {
            this.nextState = "over";
            if (this.invokes.length > 0) {
                // Handles structured concurrency
                const val = this.invokes.pop();
                return {
                    type: "internal.await",
                    id: val.id,
                    promise: {
                        type: "internal.promise",
                        state: "pending",
                        mode: "attached",
                        id: val.id,
                    },
                };
            }
            return {
                type: "internal.return",
                value: this.toLiteral(result.value),
            };
        }
        return this.toInternal(result.value);
    }
    // From internal type to external type
    // Having to return a Result<> is an artifact of not being able to check
    // the instance of "Result" at runtime
    toExternal(value) {
        switch (value.type) {
            case "internal.nothing":
                return (0, types_1.ok)(undefined);
            case "internal.promise":
                if (value.state === "pending") {
                    return (0, types_1.ok)(new context_1.Future(value.id, "pending", undefined, value.mode));
                }
                // promise === "complete"
                // We know for sure this promise relates to the last invoke inserted
                this.invokes.pop();
                return (0, types_1.ok)(new context_1.Future(value.id, "completed", value.value.value));
            case "internal.literal":
                return value.value;
        }
    }
    // From external type to internal type
    toInternal(event) {
        if (event instanceof context_1.LFI || event instanceof context_1.LFC) {
            this.invokes.push({
                kind: event instanceof context_1.LFI ? "invoke" : "call",
                id: event.id,
            });
            this.nextState = "internal.promise";
            return {
                type: "internal.async.l",
                id: event.id,
                func: event.func,
                args: event.args ?? [],
                version: event.version,
                retryPolicy: event.retryPolicy,
                createReq: event.createReq,
            };
        }
        if (event instanceof context_1.RFI || event instanceof context_1.RFC) {
            if (event.mode === "attached") {
                this.invokes.push({
                    kind: event instanceof context_1.RFI ? "invoke" : "call",
                    id: event.id,
                });
            }
            this.nextState = "internal.promise";
            return {
                type: "internal.async.r",
                id: event.id,
                mode: event.mode,
                func: event.func,
                version: event.version,
                createReq: event.createReq,
            };
        }
        if (event instanceof context_1.DIE) {
            this.nextState = "internal.nothing";
            return {
                type: "internal.die",
                condition: event.condition,
                error: event.error,
            };
        }
        if (event instanceof context_1.Future) {
            // Map Future to InternalPromise union
            if (event.state === "completed") {
                this.nextState = "internal.literal";
                return {
                    type: "internal.await",
                    id: event.id,
                    promise: {
                        type: "internal.promise",
                        state: "completed",
                        id: event.id,
                        value: {
                            type: "internal.literal",
                            // biome-ignore lint/complexity/useLiteralKeys: We need to access this private member, it is only private to the user
                            value: event["value"],
                        },
                    },
                };
            }
            // If the Future was completed (the promise was completed) we already poped the related invoke,
            // when the user awaits the future we remove it from the invokes
            this.invokes = this.invokes.filter(({ id }) => id !== event.id);
            this.nextState = "over";
            return {
                type: "internal.await",
                id: event.id,
                promise: {
                    type: "internal.promise",
                    state: "pending",
                    // biome-ignore lint/complexity/useLiteralKeys: We need to access this private member, it is only private to the user
                    mode: event["mode"],
                    id: event.id,
                },
            };
        }
        throw new Error("Unexpected input to extToInt");
    }
    toLiteral(result) {
        return {
            type: "internal.literal",
            value: result,
        };
    }
    safeGeneratorNext(value) {
        try {
            let itResult;
            if (!value.success) {
                itResult = this.generator.throw(value.error);
            }
            else {
                itResult = this.generator.next(value.value);
            }
            if (!itResult.done) {
                return itResult;
            }
            return {
                done: true,
                value: (0, types_1.ok)(itResult.value),
            };
        }
        catch (e) {
            return {
                done: true,
                value: (0, types_1.ko)(e),
            };
        }
    }
}
exports.Decorator = Decorator;
//# sourceMappingURL=decorator.js.map