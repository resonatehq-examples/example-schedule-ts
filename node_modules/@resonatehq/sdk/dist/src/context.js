"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InnerContext = exports.Future = exports.DIE = exports.RFC = exports.RFI = exports.LFC = exports.LFI = void 0;
const exceptions_1 = __importDefault(require("./exceptions"));
const retries_1 = require("./retries");
const util = __importStar(require("./util"));
class LFI {
    id;
    func;
    args;
    version;
    retryPolicy;
    createReq;
    constructor(id, func, args, version, retryPolicy, createReq) {
        this.id = id;
        this.func = func;
        this.args = args;
        this.version = version;
        this.retryPolicy = retryPolicy;
        this.createReq = createReq;
    }
    *[Symbol.iterator]() {
        const v = yield this;
        util.assert(v instanceof Future, "expected future");
        return v;
    }
}
exports.LFI = LFI;
class LFC {
    id;
    func;
    args;
    version;
    retryPolicy;
    createReq;
    constructor(id, func, args, version, retryPolicy, createReq) {
        this.id = id;
        this.func = func;
        this.args = args;
        this.version = version;
        this.retryPolicy = retryPolicy;
        this.createReq = createReq;
    }
    *[Symbol.iterator]() {
        const v = yield this;
        util.assert(!(v instanceof Future), "expected value");
        return v;
    }
}
exports.LFC = LFC;
class RFI {
    id;
    func;
    version;
    createReq;
    mode;
    constructor(id, func, version, createReq, mode = "attached") {
        this.id = id;
        this.func = func;
        this.version = version;
        this.createReq = createReq;
        this.mode = mode;
    }
    *[Symbol.iterator]() {
        const v = yield this;
        util.assert(v instanceof Future, "expected future");
        return v;
    }
}
exports.RFI = RFI;
class RFC {
    id;
    func;
    version;
    createReq;
    mode = "attached";
    constructor(id, func, version, createReq) {
        this.id = id;
        this.func = func;
        this.version = version;
        this.createReq = createReq;
    }
    *[Symbol.iterator]() {
        const v = yield this;
        util.assert(!(v instanceof Future), "expected value");
        return v;
    }
}
exports.RFC = RFC;
class DIE {
    condition;
    error;
    constructor(condition, error) {
        this.condition = condition;
        this.error = error;
    }
    *[Symbol.iterator]() {
        yield this;
        return;
    }
}
exports.DIE = DIE;
class Future {
    id;
    value;
    state;
    mode;
    constructor(id, state, value, mode = "attached") {
        this.id = id;
        this.value = value;
        this.state = state;
        this.mode = mode;
    }
    getValue() {
        if (!this.value) {
            throw new Error("Future is not ready");
        }
        if (this.value.success) {
            return this.value.value;
        }
        throw this.value.error; // Should be unreachble
    }
    *[Symbol.iterator]() {
        yield this;
        util.assertDefined(this.value);
        util.assert(this.value.success, "The value must be and ok result at this point.");
        return this.getValue();
    }
}
exports.Future = Future;
class InnerContext {
    id;
    info;
    func;
    retryPolicy;
    rootId;
    parentId;
    clock;
    span;
    registry;
    dependencies;
    optsBuilder;
    seq = 0;
    run = this.lfc.bind(this);
    rpc = this.rfc.bind(this);
    beginRun = this.lfi.bind(this);
    beginRpc = this.rfi.bind(this);
    constructor({ id, rId = id, pId = id, func, clock, registry, dependencies, optsBuilder, timeout, version, retryPolicy, span, }) {
        this.id = id;
        this.rootId = rId;
        this.parentId = pId;
        this.func = func;
        this.clock = clock;
        this.registry = registry;
        this.dependencies = dependencies;
        this.optsBuilder = optsBuilder;
        this.retryPolicy = retryPolicy;
        this.span = span;
        this.info = {
            attempt: 1,
            timeout,
            version,
        };
    }
    child({ id, func, timeout, version, retryPolicy, span, }) {
        return new InnerContext({
            id,
            rId: this.rootId,
            pId: this.id,
            func,
            clock: this.clock,
            registry: this.registry,
            dependencies: this.dependencies,
            optsBuilder: this.optsBuilder,
            timeout,
            version,
            retryPolicy,
            span,
        });
    }
    lfi(funcOrName, ...args) {
        const [argu, opts] = util.splitArgsAndOpts(args, this.options());
        const registered = this.registry.get(funcOrName, opts.version);
        if (typeof funcOrName === "string" && !registered) {
            // This results in a dropped task and a value will never be
            // yielded back to the users coroutine. However, the type
            // system indicates the value is void. Casting to LFI "tricks"
            // the type system to indicate the correct type.
            return new DIE(true, exceptions_1.default.REGISTRY_FUNCTION_NOT_REGISTERED(funcOrName, opts.version));
        }
        const id = opts.id ?? this.seqid();
        this.seq++;
        const func = registered ? registered.func : funcOrName;
        const version = registered ? registered.version : 1;
        return new LFI(id, func, argu, version, opts.retryPolicy ?? (util.isGeneratorFunction(func) ? new retries_1.Never() : new retries_1.Exponential()), this.localCreateReq(id, { func: func.name, version }, opts));
    }
    lfc(funcOrName, ...args) {
        const [argu, opts] = util.splitArgsAndOpts(args, this.options());
        const registered = this.registry.get(funcOrName, opts.version);
        if (typeof funcOrName === "string" && !registered) {
            // This results in a dropped task and a value will never be
            // yielded back to the users coroutine. However, the type
            // system indicates the value is void. Casting to LFC "tricks"
            // the type system to indicate the correct type.
            return new DIE(true, exceptions_1.default.REGISTRY_FUNCTION_NOT_REGISTERED(funcOrName, opts.version));
        }
        const id = opts.id ?? this.seqid();
        this.seq++;
        const func = registered ? registered.func : funcOrName;
        const version = registered ? registered.version : 1;
        return new LFC(id, func, argu, version, opts.retryPolicy ?? (util.isGeneratorFunction(func) ? new retries_1.Never() : new retries_1.Exponential()), this.localCreateReq(id, { func: func.name, version }, opts));
    }
    rfi(funcOrName, ...args) {
        const [argu, opts] = util.splitArgsAndOpts(args, this.options());
        const registered = this.registry.get(funcOrName, opts.version);
        if (typeof funcOrName === "function" && !registered) {
            // This results in a dropped task and a value will never be
            // yielded back to the users coroutine. However, the type
            // system indicates the value is void. Casting to RFI "tricks"
            // the type system to indicate the correct type.
            return new DIE(true, exceptions_1.default.REGISTRY_FUNCTION_NOT_REGISTERED(funcOrName.name, opts.version));
        }
        const id = opts.id ?? this.seqid();
        this.seq++;
        const func = registered ? registered.name : funcOrName;
        const version = registered ? registered.version : 1;
        const data = {
            func: func,
            args: argu,
            retry: opts.retryPolicy?.encode(),
            version: registered ? registered.version : opts.version || 1,
        };
        return new RFI(id, func, version, this.remoteCreateReq(id, data, opts));
    }
    rfc(funcOrName, ...args) {
        const [argu, opts] = util.splitArgsAndOpts(args, this.options());
        const registered = this.registry.get(funcOrName, opts.version);
        if (typeof funcOrName === "function" && !registered) {
            // This results in a dropped task and a value will never be
            // yielded back to the users coroutine. However, the type
            // system indicates the value is void. Casting to RFC "tricks"
            // the type system to indicate the correct type.
            return new DIE(true, exceptions_1.default.REGISTRY_FUNCTION_NOT_REGISTERED(funcOrName.name, opts.version));
        }
        const id = opts.id ?? this.seqid();
        this.seq++;
        const func = registered ? registered.name : funcOrName;
        const version = registered ? registered.version : 1;
        const data = {
            func: func,
            args: argu,
            retry: opts.retryPolicy?.encode(),
            version: registered ? registered.version : opts.version || 1,
        };
        return new RFC(id, func, version, this.remoteCreateReq(id, data, opts));
    }
    detached(funcOrName, ...args) {
        const [argu, opts] = util.splitArgsAndOpts(args, this.options());
        const registered = this.registry.get(funcOrName, opts.version);
        if (typeof funcOrName === "function" && !registered) {
            // This results in a dropped task and a value will never be
            // yielded back to the users coroutine. However, the type
            // system indicates the value is void. Casting to RFI "tricks"
            // the type system to indicate the correct type.
            return new DIE(true, exceptions_1.default.REGISTRY_FUNCTION_NOT_REGISTERED(funcOrName.name, opts.version));
        }
        const id = opts.id ?? this.seqid();
        this.seq++;
        const func = registered ? registered.name : funcOrName;
        const version = registered ? registered.version : 1;
        const data = {
            func: func,
            args: argu,
            retry: opts.retryPolicy?.encode(),
            version: registered ? registered.version : opts.version || 1,
        };
        return new RFI(id, func, version, this.remoteCreateReq(id, data, opts, Number.MAX_SAFE_INTEGER), "detached");
    }
    promise({ id, timeout, data, tags, } = {}) {
        id = id ?? this.seqid();
        this.seq++;
        return new RFI(id, "unknown", 1, this.latentCreateOpts(id, timeout, data, tags));
    }
    sleep(msOrOpts) {
        let until;
        if (typeof msOrOpts === "number") {
            until = this.clock.now() + msOrOpts;
        }
        else if (msOrOpts.for != null) {
            until = this.clock.now() + msOrOpts.for;
        }
        else if (msOrOpts.until != null) {
            until = msOrOpts.until.getTime();
        }
        else {
            until = 0;
        }
        const id = this.seqid();
        this.seq++;
        return new RFC(id, "sleep", 1, this.sleepCreateOpts(id, until));
    }
    panic(condition, msg) {
        const src = util.getCallerInfo();
        return new DIE(condition, exceptions_1.default.PANIC(src, msg));
    }
    assert(condition, msg) {
        return this.panic(!condition, msg);
    }
    getDependency(name) {
        return this.dependencies.get(name);
    }
    options(opts = {}) {
        return this.optsBuilder.build(opts);
    }
    date = {
        now: () => this.lfc((this.getDependency("resonate:date") ?? Date).now),
    };
    math = {
        random: () => this.lfc((this.getDependency("resonate:math") ?? Math).random),
    };
    localCreateReq(id, data, opts) {
        const tags = {
            "resonate:scope": "local",
            "resonate:root": this.rootId,
            "resonate:parent": this.id,
            ...opts.tags,
        };
        // timeout cannot be greater than parent timeout
        const timeout = Math.min(this.clock.now() + opts.timeout, this.info.timeout);
        return {
            kind: "createPromise",
            id,
            timeout: timeout,
            param: { data },
            tags,
            iKey: id,
            strict: false,
        };
    }
    remoteCreateReq(id, data, opts, maxTimeout = this.info.timeout) {
        const tags = {
            "resonate:scope": "global",
            "resonate:invoke": opts.target,
            "resonate:root": this.rootId,
            "resonate:parent": this.id,
            ...opts.tags,
        };
        // timeout cannot be greater than parent timeout (unless detached)
        const timeout = Math.min(this.clock.now() + opts.timeout, maxTimeout);
        return {
            kind: "createPromise",
            id,
            timeout,
            tags,
            param: { data },
            iKey: id,
            strict: false,
        };
    }
    latentCreateOpts(id, timeout, data, tags) {
        const cTags = {
            "resonate:scope": "global",
            "resonate:root": this.rootId,
            "resonate:parent": this.id,
            ...tags,
        };
        // timeout cannot be greater than parent timeout
        const cTimeout = Math.min(this.clock.now() + (timeout ?? 24 * util.HOUR), this.info.timeout);
        return {
            kind: "createPromise",
            id: id,
            timeout: cTimeout,
            param: { data },
            tags: cTags,
            iKey: id,
            strict: false,
        };
    }
    sleepCreateOpts(id, time) {
        const tags = {
            "resonate:scope": "global",
            "resonate:root": this.rootId,
            "resonate:parent": this.id,
            "resonate:timeout": "true",
        };
        // timeout cannot be greater than parent timeout
        const timeout = Math.min(time, this.info.timeout);
        return {
            kind: "createPromise",
            id: id,
            timeout: timeout,
            param: {},
            tags,
            iKey: id,
            strict: false,
        };
    }
    seqid() {
        return `${this.id}.${this.seq}`;
    }
}
exports.InnerContext = InnerContext;
//# sourceMappingURL=context.js.map