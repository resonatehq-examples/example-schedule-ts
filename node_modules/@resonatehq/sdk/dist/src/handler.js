"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Handler = exports.Cache = void 0;
const exceptions_1 = __importDefault(require("./exceptions"));
const util = __importStar(require("./util"));
class Cache {
    promises = new Map();
    callbacks = new Map();
    tasks = new Map();
    getPromise(id) {
        return this.promises.get(id);
    }
    setPromise(promise) {
        // do not set when promise is already completed
        if (this.promises.get(promise.id) !== undefined && this.promises.get(promise.id)?.state !== "pending") {
            return;
        }
        this.promises.set(promise.id, promise);
    }
    getCallback(id) {
        return this.callbacks.get(id);
    }
    setCallback(id, callback) {
        this.callbacks.set(id, callback);
    }
    getTask(id) {
        return this.tasks.get(id);
    }
    setTask(task) {
        // do not set when counter is greater
        if ((this.tasks.get(task.id)?.counter || 0) >= task.counter) {
            return;
        }
        this.tasks.set(task.id, task);
    }
}
exports.Cache = Cache;
class Handler {
    cache = new Cache();
    network;
    encoder;
    encryptor;
    constructor(network, encoder, encryptor) {
        this.network = network;
        this.encoder = encoder;
        this.encryptor = encryptor;
    }
    readPromise(req, done) {
        const promise = this.cache.getPromise(req.id);
        if (promise) {
            done(undefined, promise);
            return;
        }
        this.network.send(req, (err, res) => {
            if (err)
                return done(err);
            util.assertDefined(res);
            let promise;
            try {
                promise = this.decode(res.promise);
            }
            catch (e) {
                return done(e);
            }
            this.cache.setPromise(promise);
            done(undefined, promise);
        });
    }
    createPromise(req, done, func = "unknown", headers = {}, retryForever = false) {
        const promise = this.cache.getPromise(req.id);
        if (promise) {
            done(undefined, promise);
            return;
        }
        let param;
        try {
            param = this.encryptor.encrypt(this.encoder.encode(req.param?.data));
        }
        catch (e) {
            done(exceptions_1.default.ENCODING_ARGS_UNENCODEABLE(req.param?.data?.func ?? func, e));
            return;
        }
        this.network.send({ ...req, param }, (err, res) => {
            if (err)
                return done(err);
            util.assertDefined(res);
            let promise;
            try {
                promise = this.decode(res.promise, req.param?.data?.func ?? func);
            }
            catch (e) {
                return done(e);
            }
            this.cache.setPromise(promise);
            done(undefined, promise);
        }, headers, retryForever);
    }
    createPromiseAndTask(req, done, func = "unknown", headers = {}, retryForever = false) {
        const promise = this.cache.getPromise(req.promise.id);
        if (promise) {
            done(undefined, { promise });
            return;
        }
        let param;
        try {
            param = this.encryptor.encrypt(this.encoder.encode(req.promise.param?.data));
        }
        catch (e) {
            done(exceptions_1.default.ENCODING_ARGS_UNENCODEABLE(req.promise.param?.data?.func ?? func, e));
            return;
        }
        this.network.send({ ...req, promise: { ...req.promise, param } }, (err, res) => {
            if (err)
                return done(err);
            util.assertDefined(res);
            let promise;
            try {
                promise = this.decode(res.promise, req.promise.param?.data?.func ?? func);
            }
            catch (e) {
                return done(e);
            }
            this.cache.setPromise(promise);
            if (res.task) {
                this.cache.setTask(res.task);
            }
            done(undefined, { promise, task: res.task });
        }, headers, retryForever);
    }
    completePromise(req, done, func = "unknown") {
        const promise = this.cache.getPromise(req.id);
        util.assertDefined(promise);
        if (promise.state !== "pending") {
            done(undefined, promise);
            return;
        }
        let value;
        try {
            value = this.encryptor.encrypt(this.encoder.encode(req.value?.data));
        }
        catch (e) {
            done(exceptions_1.default.ENCODING_RETV_UNENCODEABLE(func, e));
            return;
        }
        this.network.send({ ...req, value }, (err, res) => {
            if (err)
                return done(err);
            util.assertDefined(res);
            let promise;
            try {
                promise = this.decode(res.promise, func);
            }
            catch (e) {
                return done(e);
            }
            this.cache.setPromise(promise);
            done(undefined, promise);
        });
    }
    claimTask(req, done) {
        const task = this.cache.getTask(req.id);
        if (task && task.counter >= req.counter) {
            done(exceptions_1.default.ENCODING_RETV_UNDECODEABLE("The task counter is invalid", {
                code: 40307,
                message: "The task counter is invalid",
            }));
            return;
        }
        this.network.send(req, (err, res) => {
            if (err)
                return done(err);
            util.assertDefined(res);
            util.assertDefined(res.message.promises.root);
            let rootPromise;
            let leafPromise;
            try {
                rootPromise = this.decode(res.message.promises.root.data);
                if (res.message.promises.leaf) {
                    leafPromise = this.decode(res.message.promises.leaf.data);
                }
            }
            catch (e) {
                return done(e);
            }
            this.cache.setPromise(rootPromise);
            if (leafPromise) {
                this.cache.setPromise(leafPromise);
            }
            this.cache.setTask({ id: req.id, counter: req.counter });
            done(undefined, { root: rootPromise, leaf: leafPromise });
        });
    }
    createCallback(req, done, headers = {}) {
        const id = `__resume:${req.rootPromiseId}:${req.promiseId}`;
        const promise = this.cache.getPromise(req.promiseId);
        util.assertDefined(promise);
        if (promise.state !== "pending") {
            done(undefined, { kind: "promise", promise });
            return;
        }
        const callback = this.cache.getCallback(id);
        if (callback) {
            done(undefined, { kind: "callback", callback });
            return;
        }
        this.network.send(req, (err, res) => {
            if (err)
                return done(err);
            util.assertDefined(res);
            if (res.promise) {
                let promise;
                try {
                    promise = this.decode(res.promise);
                }
                catch (e) {
                    return done(e);
                }
                this.cache.setPromise(promise);
            }
            if (res.callback) {
                this.cache.setCallback(id, res.callback);
            }
            done(undefined, res.callback ? { kind: "callback", callback: res.callback } : { kind: "promise", promise: res.promise });
        }, headers);
    }
    createSubscription(req, done, retryForever = false) {
        const id = `__notify:${req.promiseId}:${req.id}`;
        const promise = this.cache.getPromise(req.promiseId);
        util.assertDefined(promise);
        if (promise.state !== "pending") {
            done(undefined, promise);
            return;
        }
        const callback = this.cache.getCallback(id);
        if (callback) {
            done(undefined, promise);
            return;
        }
        this.network.send(req, (err, res) => {
            if (err)
                return done(err);
            util.assertDefined(res);
            let promise;
            try {
                promise = this.decode(res.promise);
            }
            catch (e) {
                return done(e);
            }
            this.cache.setPromise(promise);
            if (res.callback) {
                this.cache.setCallback(id, res.callback);
            }
            done(undefined, promise);
        }, {}, retryForever);
    }
    decode(promise, func = "unknown") {
        let paramData;
        let valueData;
        try {
            paramData = this.encoder.decode(this.encryptor.decrypt(promise.param));
        }
        catch (e) {
            throw exceptions_1.default.ENCODING_ARGS_UNDECODEABLE(func, e);
        }
        try {
            valueData = this.encoder.decode(this.encryptor.decrypt(promise.value));
        }
        catch (e) {
            throw exceptions_1.default.ENCODING_RETV_UNDECODEABLE(paramData?.func ?? func, e);
        }
        return {
            ...promise,
            param: { headers: promise.param?.headers, data: paramData },
            value: { headers: promise.value?.headers, data: valueData },
        };
    }
}
exports.Handler = Handler;
//# sourceMappingURL=handler.js.map