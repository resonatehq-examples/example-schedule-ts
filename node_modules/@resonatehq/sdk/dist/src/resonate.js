"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Resonate = void 0;
const network_1 = require("../dev/network");
const clock_1 = require("./clock");
const encoder_1 = require("./encoder");
const encryptor_1 = require("./encryptor");
const exceptions_1 = __importDefault(require("./exceptions"));
const handler_1 = require("./handler");
const heartbeat_1 = require("./heartbeat");
const remote_1 = require("./network/remote");
const options_1 = require("./options");
const promises_1 = require("./promises");
const registry_1 = require("./registry");
const resonate_inner_1 = require("./resonate-inner");
const schedules_1 = require("./schedules");
const tracer_1 = require("./tracer");
const util = __importStar(require("./util"));
class Resonate {
    clock;
    pid;
    ttl;
    idPrefix;
    unicast;
    anycast;
    match;
    inner;
    network;
    encoder;
    encryptor;
    verbose;
    messageSource;
    tracer;
    handler;
    registry;
    heartbeat;
    dependencies;
    optsBuilder;
    subscriptions = new Map();
    subscribeEvery;
    intervalId;
    promises;
    schedules;
    constructor({ url = undefined, group = "default", pid = undefined, ttl = 1 * util.MIN, auth = undefined, token = undefined, verbose = false, encryptor = undefined, tracer = undefined, transport = undefined, prefix = undefined, } = {}) {
        this.clock = new clock_1.WallClock();
        this.ttl = ttl;
        this.tracer = tracer ?? new tracer_1.NoopTracer();
        this.encryptor = encryptor ?? new encryptor_1.NoopEncryptor();
        this.encoder = new encoder_1.JsonEncoder();
        const resolvedPrefix = prefix ?? process.env.RESONATE_PREFIX;
        this.idPrefix = resolvedPrefix ? `${resolvedPrefix}:` : "";
        this.verbose = verbose;
        this.subscribeEvery = 60 * 1000; // make this configurable
        // Determine the URL based on priority: url arg > RESONATE_URL > RESONATE_HOST+PORT
        let resolvedUrl = url;
        if (!resolvedUrl) {
            if (process.env.RESONATE_URL) {
                resolvedUrl = process.env.RESONATE_URL;
            }
            else {
                const resonateScheme = process.env.RESONATE_SCHEME ?? "http";
                const resonateHost = process.env.RESONATE_HOST;
                const resonatePort = process.env.RESONATE_PORT ?? "8001";
                if (resonateHost) {
                    resolvedUrl = `${resonateScheme}://${resonateHost}:${resonatePort}`;
                }
            }
        }
        // Determine the token based on priority: token arg > RESONATE_TOKEN
        const resolvedToken = token ?? process.env.RESONATE_TOKEN;
        // Determine the auth based on priority: auth arg > RESONATE_USERNAME+RESONATE_PASSWORD
        let resolvedAuth = auth;
        if (!resolvedAuth) {
            const resonateUsername = process.env.RESONATE_USERNAME;
            const resonatePassword = process.env.RESONATE_PASSWORD ?? "";
            if (resonateUsername) {
                resolvedAuth = { username: resonateUsername, password: resonatePassword };
            }
        }
        if (transport) {
            this.network = transport;
            if (util.isMessageSource(transport)) {
                this.messageSource = transport;
            }
            else if (transport.getMessageSource) {
                this.messageSource = transport.getMessageSource();
            }
            else {
                // TODO: instantiate default message source instead
                throw new Error("transport must implement both network and message source");
            }
            this.pid = pid ?? this.messageSource.pid;
            this.heartbeat = new heartbeat_1.AsyncHeartbeat(this.pid, ttl / 2, this.network);
        }
        else {
            if (!resolvedUrl) {
                const localNetwork = new network_1.LocalNetwork({ pid, group });
                this.network = localNetwork;
                this.messageSource = localNetwork.getMessageSource();
                this.pid = pid ?? this.messageSource.pid;
                this.heartbeat = new heartbeat_1.NoopHeartbeat();
            }
            else {
                this.network = new remote_1.HttpNetwork({
                    verbose: this.verbose,
                    url: resolvedUrl,
                    auth: resolvedAuth,
                    token: resolvedToken,
                    timeout: 1 * util.MIN,
                    headers: {},
                });
                this.messageSource = new remote_1.PollMessageSource({
                    url: resolvedUrl,
                    pid,
                    group,
                    auth: resolvedAuth,
                    token: resolvedToken,
                });
                this.pid = pid ?? this.messageSource.pid;
                this.heartbeat = new heartbeat_1.AsyncHeartbeat(this.pid, ttl / 2, this.network);
            }
        }
        this.handler = new handler_1.Handler(this.network, this.encoder, this.encryptor);
        this.registry = new registry_1.Registry();
        this.dependencies = new Map();
        this.unicast = this.messageSource.unicast;
        this.anycast = this.messageSource.anycast;
        this.match = this.messageSource.match;
        this.optsBuilder = new options_1.OptionsBuilder({ match: this.match, idPrefix: this.idPrefix });
        this.inner = new resonate_inner_1.ResonateInner({
            unicast: this.unicast,
            anycast: this.anycast,
            pid: this.pid,
            ttl: this.ttl,
            clock: this.clock,
            network: this.network,
            messageSource: this.messageSource,
            handler: this.handler,
            registry: this.registry,
            heartbeat: this.heartbeat,
            dependencies: this.dependencies,
            optsBuilder: this.optsBuilder,
            verbose: this.verbose,
            tracer: this.tracer,
        });
        this.promises = new promises_1.Promises(this.network);
        this.schedules = new schedules_1.Schedules(this.network);
        // subscribe to notify
        this.messageSource.subscribe("notify", this.onMessage.bind(this));
        // periodically refresh subscriptions
        this.intervalId = setInterval(async () => {
            for (const [id, sub] of this.subscriptions.entries()) {
                try {
                    const createSubscriptionReq = {
                        kind: "createSubscription",
                        id: this.pid,
                        promiseId: id,
                        timeout: sub.timeout + 1 * util.MIN, // add a buffer
                        recv: this.unicast,
                    };
                    const res = await this.createSubscription(createSubscriptionReq);
                    if (res.state !== "pending") {
                        sub.resolve(res);
                        this.subscriptions.delete(id);
                    }
                }
                catch {
                    // silently skip on error
                }
            }
        }, this.subscribeEvery);
    }
    /**
     * Initializes a Resonate client instance for local development.
     *
     * Creates and returns a Resonate client configured for **local-only execution**
     * with zero external dependencies. All state is stored in local memory â€” no
     * network or external persistence is required. This mode is ideal for rapid
     * testing, debugging, and experimentation before connecting to a Resonate server.
     *
     * The client runs with a `"default"` worker group, a `"default"` process ID,
     * and an effectively infinite TTL (`Number.MAX_SAFE_INTEGER`) for tasks.
     *
     * @returns A {@link Resonate} client instance configured for local development.
     *
     * @example
     * ```ts
     * const resonate = Resonate.local();
     * resonate.register(foo);
     * const result = await resonate.run("foo.1", foo, { data: "test" });
     * console.log(result);
     * ```
     */
    static local({ verbose = false, encryptor = undefined, tracer = undefined, } = {}) {
        return new Resonate({
            group: "default",
            pid: "default",
            ttl: Number.MAX_SAFE_INTEGER,
            verbose,
            encryptor,
            tracer,
        });
    }
    /**
     * Initializes a Resonate client instance with remote configuration.
     *
     * Creates and returns a Resonate client that connects to a **Resonate Server**
     * and optional remote message sources. This configuration enables distributed,
     * durable workers to cooperate and execute functions via **durable RPCs**.
     *
     * By default, the client connects to a Resonate Server running locally
     * (`http://localhost:8001`) and joins the `"default"` worker group.
     *
     * The client is identified by a unique process ID (`pid`) and maintains
     * claimed task leases for the duration specified by `ttl`.
     *
     * @param options - Configuration options for the remote client.
     * @param options.url - The base URL of the remote Resonate Server. Defaults to `"http://localhost:8001"`.
     * @param options.group - The worker group name. Defaults to `"default"`.
     * @param options.pid - Optional process identifier for the client. Defaults to a randomly generated UUID.
     * @param options.ttl - Time-to-live (in seconds) for claimed tasks. Defaults to `1 * util.MIN`.
     * @param options.auth - Optional authentication credentials for connecting to the remote server.
     * @param options.token - Optional bearer token for authentication. Takes priority over basic auth.
     *
     * @returns A {@link Resonate} client instance configured for remote operation.
     *
     * @example
     * ```ts
     * const resonate = Resonate.remote({
     *   url: "https://resonate.example.com",
     *   group: "analytics",
     *   ttl: 30,
     *   token: "bearer-token-here",
     * });
     *
     * const result = await resonate.run("task-42", "processData", { input: "dataset.csv" });
     * console.log(result);
     * ```
     */
    static remote({ url = "http://localhost:8001", group = "default", pid = crypto.randomUUID().replace(/-/g, ""), ttl = 1 * util.MIN, auth = undefined, token = undefined, verbose = false, encryptor = undefined, tracer = undefined, prefix = undefined, } = {}) {
        return new Resonate({ url, group, pid, ttl, auth, token, verbose, encryptor, tracer, prefix });
    }
    register(nameOrFunc, funcOrOptions, maybeOptions = {}) {
        const { version = 1 } = (typeof funcOrOptions === "object" ? funcOrOptions : maybeOptions) ?? {};
        const func = typeof nameOrFunc === "function" ? nameOrFunc : funcOrOptions;
        const name = typeof nameOrFunc === "string" ? nameOrFunc : func.name;
        this.registry.add(func, name, version);
        return {
            run: (id, ...args) => this.run(id, func, ...this.getArgsAndOpts(args, version)),
            rpc: (id, ...args) => this.rpc(id, func, ...this.getArgsAndOpts(args, version)),
            beginRun: (id, ...args) => this.beginRun(id, func, ...this.getArgsAndOpts(args, version)),
            beginRpc: (id, ...args) => this.beginRpc(id, func, ...this.getArgsAndOpts(args, version)),
            options: this.options,
        };
    }
    async run(id, funcOrName, ...args) {
        return (await this.beginRun(id, funcOrName, ...args)).result();
    }
    async beginRun(id, funcOrName, ...argsWithOpts) {
        const [args, opts] = this.getArgsAndOpts(argsWithOpts);
        const registered = this.registry.get(funcOrName, opts.version);
        // function must be registered
        if (!registered) {
            throw exceptions_1.default.REGISTRY_FUNCTION_NOT_REGISTERED(typeof funcOrName === "string" ? funcOrName : funcOrName.name, opts.version);
        }
        id = `${this.idPrefix}${id}`;
        util.assert(registered.version > 0, "function version must be greater than zero");
        const span = this.tracer.startSpan(id, this.clock.now());
        span.setAttribute("type", "run");
        span.setAttribute("func", registered.name);
        span.setAttribute("version", registered.version);
        try {
            const { promise, task } = await this.createPromiseAndTask({
                kind: "createPromiseAndTask",
                promise: {
                    id: id,
                    timeout: Date.now() + opts.timeout,
                    param: {
                        data: {
                            func: registered.name,
                            args: args,
                            retry: opts.retryPolicy?.encode(),
                            version: registered.version,
                        },
                    },
                    tags: {
                        ...opts.tags,
                        "resonate:root": id,
                        "resonate:parent": id,
                        "resonate:scope": "global",
                        "resonate:invoke": this.anycast,
                    },
                },
                task: {
                    processId: this.pid,
                    ttl: this.ttl,
                },
                iKey: id,
                strict: false,
            }, span.encode());
            // if the promise is created, the span is considered successful
            span.setStatus(true);
            if (task) {
                this.inner.process(span, { kind: "claimed", task: task, rootPromise: promise }, () => {
                    span.end(this.clock.now());
                });
            }
            else {
                span.end(this.clock.now());
            }
            return this.createHandle(promise);
        }
        catch (e) {
            span.setStatus(false, String(e));
            span.end(this.clock.now());
            throw e;
        }
    }
    async rpc(id, funcOrName, ...args) {
        return (await this.beginRpc(id, funcOrName, ...args)).result();
    }
    async beginRpc(id, funcOrName, ...argsWithOpts) {
        const [args, opts] = this.getArgsAndOpts(argsWithOpts);
        const registered = this.registry.get(funcOrName, opts.version);
        // function must be registered if function pointer is provided
        if (typeof funcOrName === "function" && !registered) {
            throw exceptions_1.default.REGISTRY_FUNCTION_NOT_REGISTERED(funcOrName.name, opts.version);
        }
        id = `${this.idPrefix}${id}`;
        const func = registered ? registered.name : funcOrName;
        const version = registered ? registered.version : opts.version || 1;
        const span = this.tracer.startSpan(id, this.clock.now());
        span.setAttribute("type", "rpc");
        span.setAttribute("func", func);
        span.setAttribute("version", version);
        try {
            const promise = await this.createPromise({
                kind: "createPromise",
                id: id,
                timeout: Date.now() + opts.timeout,
                param: {
                    data: {
                        func: func,
                        args: args,
                        retry: opts.retryPolicy?.encode(),
                        version: version,
                    },
                },
                tags: {
                    ...opts.tags,
                    "resonate:root": id,
                    "resonate:parent": id,
                    "resonate:scope": "global",
                    "resonate:invoke": opts.target,
                },
                iKey: id,
                strict: false,
            }, span.encode());
            // if the promise is created, the span is considered successful
            span.setStatus(true);
            span.end(this.clock.now());
            return this.createHandle(promise);
        }
        catch (e) {
            span.setStatus(false, String(e));
            span.end(this.clock.now());
            throw e;
        }
    }
    async schedule(name, cron, funcOrName, ...argsWithOpts) {
        const [args, opts] = this.getArgsAndOpts(argsWithOpts);
        const registered = this.registry.get(funcOrName, opts.version);
        // function must be registered if function pointer is provided
        if (typeof funcOrName === "function" && !registered) {
            throw exceptions_1.default.REGISTRY_FUNCTION_NOT_REGISTERED(funcOrName.name, opts.version);
        }
        // TODO: move this into the handler?
        const { headers, data } = this.encryptor.encrypt(this.encoder.encode({
            func: registered ? registered.name : funcOrName,
            args: args,
            version: registered ? registered.version : opts.version || 1,
        }));
        await this.schedules.create(name, cron, `${this.idPrefix}{{.id}}.{{.timestamp}}`, opts.timeout, {
            ikey: name,
            promiseHeaders: headers,
            promiseData: data,
            promiseTags: { ...opts.tags, "resonate:invoke": opts.target },
        });
        return {
            delete: () => this.schedules.delete(name),
        };
    }
    /**
     * Retrieves or subscribes to an existing execution by its unique ID.
     *
     * This method attaches to an existing **durable promise** identified by `id`.
     * If the associated execution is still in progress, it returns a {@link ResonateHandle}
     * that can be awaited or observed until completion. If the execution has already
     * finished, the handle is immediately resolved with the stored result.
     *
     * Notes:
     * - A durable promise with the given `id` must already exist.
     * - This operation is **non-blocking**; awaiting the returned handle will block
     *   only if the execution is still running.
     *
     * @param id - Unique identifier of the target execution or durable promise.
     *
     * @returns A {@link ResonateHandle} representing the existing execution.
     *   The handle can be awaited or queried to retrieve the final result.
     */
    async get(id) {
        id = `${this.idPrefix}${id}`;
        const promise = await this.readPromise({
            kind: "readPromise",
            id: id,
        });
        return this.createHandle(promise);
    }
    options(opts = {}) {
        return this.optsBuilder.build(opts);
    }
    getArgsAndOpts(args, version) {
        return util.splitArgsAndOpts(args, this.options({ version }));
    }
    setDependency(name, obj) {
        this.dependencies.set(name, obj);
    }
    stop() {
        this.network.stop();
        this.messageSource.stop();
        this.heartbeat.stop();
        clearInterval(this.intervalId);
    }
    createPromiseAndTask(req, headers) {
        return new Promise((resolve, reject) => this.handler.createPromiseAndTask(req, (err, res) => {
            if (err) {
                reject(err);
            }
            else {
                resolve({ promise: res.promise, task: res.task });
            }
        }, undefined, headers, true));
    }
    createPromise(req, headers) {
        return new Promise((resolve, reject) => this.handler.createPromise(req, (err, res) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(res);
            }
        }, undefined, headers, true));
    }
    createSubscription(req) {
        return new Promise((resolve, reject) => this.handler.createSubscription(req, (err, res) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(res);
            }
        }, true));
    }
    readPromise(req) {
        return new Promise((resolve, reject) => this.handler.readPromise(req, (err, res) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(res);
            }
        }));
    }
    createHandle(promise) {
        const createSubscriptionReq = {
            kind: "createSubscription",
            id: this.pid,
            promiseId: promise.id,
            timeout: promise.timeout + 1 * util.MIN, // add a buffer
            recv: this.unicast,
        };
        return {
            id: promise.id,
            done: () => this.createSubscription(createSubscriptionReq).then((res) => res.state !== "pending"),
            result: () => this.createSubscription(createSubscriptionReq).then((res) => this.subscribe(promise.id, res)),
        };
    }
    onMessage(msg) {
        util.assert(msg.type === "notify");
        if (msg.type === "notify") {
            let paramData;
            let valueData;
            try {
                paramData = this.encoder.decode(this.encryptor.decrypt(msg.promise.param));
            }
            catch (e) {
                // TODO: improve this message
                this.notify(msg.promise.id, new Error("Failed to decode promise param"));
                return;
            }
            try {
                valueData = this.encoder.decode(this.encryptor.decrypt(msg.promise.value));
            }
            catch (e) {
                // TODO: improve this message
                this.notify(msg.promise.id, new Error("Failed to decode promise value"));
                return;
            }
            this.notify(msg.promise.id, undefined, {
                ...msg.promise,
                param: { headers: msg.promise.param?.headers, data: paramData },
                value: { headers: msg.promise.value?.headers, data: valueData },
            });
        }
    }
    async subscribe(id, res) {
        const { promise, resolve, reject } = this.subscriptions.get(id) ?? Promise.withResolvers();
        if (res.state === "pending") {
            this.subscriptions.set(id, { promise, resolve, reject, timeout: res.timeout });
        }
        else {
            resolve(res);
            this.subscriptions.delete(id);
        }
        const p = await promise;
        util.assert(p.state !== "pending", "promise must be completed");
        if (p.state === "resolved") {
            return p.value?.data;
        }
        if (p.state === "rejected") {
            throw p.value?.data;
        }
        if (p.state === "rejected_canceled") {
            throw new Error("Promise canceled");
        }
        if (p.state === "rejected_timedout") {
            throw new Error("Promise timedout");
        }
    }
    notify(id, err, res) {
        const subscription = this.subscriptions.get(id);
        // notify subscribers
        if (res) {
            util.assert(res.state !== "pending", "promise must be completed");
            subscription?.resolve(res);
        }
        else {
            subscription?.reject(err);
        }
        // remove subscription
        this.subscriptions.delete(id);
    }
}
exports.Resonate = Resonate;
//# sourceMappingURL=resonate.js.map