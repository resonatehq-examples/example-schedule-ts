export declare class Random {
    private state;
    constructor(seed: number);
    random(bound: number): number;
    next(): number;
    pick<T>(list: T[]): T | undefined;
    randint(min: number, max: number): number;
}
export type Address = {
    kind: "unicast";
    iaddr: string;
} | {
    kind: "anycast";
    gaddr: string;
    iaddr?: string;
};
export declare function unicast(iaddr: string): Address;
export declare function anycast(gaddr: string, iaddr?: string): Address;
export declare class Message<T> {
    source: Address;
    target: Address;
    data: T;
    head: Record<string, any>;
    constructor(source: Address, target: Address, data: T, head?: Record<string, any>);
    isRequest(): boolean;
    isResponse(): boolean;
    resp<U>(data: U): Message<U>;
}
export declare class Process {
    readonly iaddr: string;
    readonly gaddr?: string | undefined;
    active: boolean;
    constructor(iaddr: string, gaddr?: string | undefined);
    tick(tick: number, messages: Message<any>[]): Message<any>[];
    log(tick: number, ...args: any[]): void;
}
export interface DeliveryOptions {
    dropProb?: number;
    randomDelay?: number;
    duplProb?: number;
    deactivateProb?: number;
    activateProb?: number;
}
export declare class Simulator {
    private prng;
    step: number;
    private init;
    private process;
    private network;
    outbox: Message<any>[];
    deliveryOptions: Required<DeliveryOptions>;
    private scheduledRepeat;
    private scheduledDelay;
    constructor(prng: Random, { dropProb, randomDelay, duplProb, deactivateProb, activateProb }?: DeliveryOptions);
    addMessage(message: Message<any>): void;
    assertAlways(cond: boolean, msg: string): void;
    register(process: Process): void;
    more(): boolean;
    send(message: Message<any>): void;
    tick(): void;
    exec(steps: number): void;
    repeat(interval: number, fn: () => void): void;
    delay(runAt: number, fn: () => void): void;
}
//# sourceMappingURL=simulator.d.ts.map