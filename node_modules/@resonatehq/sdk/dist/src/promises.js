"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Promises = void 0;
const network_1 = require("../dev/network");
class Promises {
    network;
    constructor(network = new network_1.LocalNetwork()) {
        this.network = network;
    }
    get(id) {
        return new Promise((resolve, reject) => {
            this.network.send({ kind: "readPromise", id }, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res.promise);
            });
        });
    }
    create(id, timeout, { ikey = undefined, strict = false, headers = undefined, data = undefined, tags = undefined, } = {}) {
        return new Promise((resolve, reject) => {
            this.network.send({
                kind: "createPromise",
                id: id,
                timeout: timeout,
                param: { headers, data },
                tags: tags,
                iKey: ikey,
                strict: strict,
            }, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res.promise);
            });
        });
    }
    createWithTask(id, timeout, pid, ttl, { ikey = undefined, strict = false, headers = undefined, data = undefined, tags = undefined, } = {}) {
        return new Promise((resolve, reject) => {
            this.network.send({
                kind: "createPromiseAndTask",
                promise: {
                    id: id,
                    timeout: timeout,
                    param: { headers, data },
                    tags: tags,
                },
                task: {
                    processId: pid,
                    ttl: ttl,
                },
                iKey: ikey,
                strict: strict,
            }, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve({ promise: res.promise, task: res.task });
            });
        });
    }
    resolve(id, { ikey = undefined, strict = false, headers = undefined, data = undefined, } = {}) {
        return new Promise((resolve, reject) => {
            this.network.send({
                kind: "completePromise",
                id: id,
                state: "resolved",
                value: { headers, data },
                iKey: ikey,
                strict: strict,
            }, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res.promise);
            });
        });
    }
    reject(id, { ikey = undefined, strict = false, headers = undefined, data = undefined, } = {}) {
        return new Promise((resolve, reject) => {
            this.network.send({
                kind: "completePromise",
                id: id,
                state: "rejected",
                value: { headers, data },
                iKey: ikey,
                strict: strict,
            }, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res.promise);
            });
        });
    }
    cancel(id, { ikey = undefined, strict = false, headers = undefined, data = undefined, } = {}) {
        return new Promise((resolve, reject) => {
            this.network.send({
                kind: "completePromise",
                id: id,
                state: "rejected_canceled",
                value: { headers, data },
                iKey: ikey,
                strict: strict,
            }, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(res.promise);
            });
        });
    }
    async *search(id, { state = undefined, limit = undefined } = {}) {
        let cursor;
        do {
            const res = await new Promise((resolve, reject) => {
                this.network.send({
                    kind: "searchPromises",
                    id,
                    state,
                    limit,
                    cursor,
                }, (err, res) => {
                    if (err)
                        return reject(err);
                    resolve(res);
                });
            });
            cursor = res.cursor;
            yield res.promises;
        } while (cursor !== null && cursor !== undefined);
    }
    callback(promiseId, rootPromiseId, recv, timeout) {
        return new Promise((resolve, reject) => {
            this.network.send({
                kind: "createCallback",
                promiseId: promiseId,
                rootPromiseId: rootPromiseId,
                timeout: timeout,
                recv: recv,
            }, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve({ promise: res.promise, callback: res.callback });
            });
        });
    }
    subscribe(id, promiseId, timeout, recv) {
        return new Promise((resolve, reject) => {
            this.network.send({ kind: "createSubscription", id, promiseId, timeout, recv }, (err, res) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve({ promise: res.promise, callback: res.callback });
            });
        });
    }
}
exports.Promises = Promises;
//# sourceMappingURL=promises.js.map