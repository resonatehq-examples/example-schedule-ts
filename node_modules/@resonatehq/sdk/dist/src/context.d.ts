import type { Clock } from "./clock";
import { type ResonateError } from "./exceptions";
import type { CreatePromiseReq } from "./network/network";
import type { Options, OptionsBuilder } from "./options";
import type { Registry } from "./registry";
import { type RetryPolicy } from "./retries";
import type { Span } from "./tracer";
import type { Func, ParamsWithOptions, Result, Return } from "./types";
export declare class LFI<T> implements Iterable<LFI<T>> {
    id: string;
    func: Func;
    args: any[];
    version: number;
    retryPolicy: RetryPolicy;
    createReq: CreatePromiseReq<any>;
    constructor(id: string, func: Func, args: any[], version: number, retryPolicy: RetryPolicy, createReq: CreatePromiseReq<any>);
    [Symbol.iterator](): Generator<LFI<T>, Future<T>, any>;
}
export declare class LFC<T> implements Iterable<LFC<T>> {
    id: string;
    func: Func;
    args: any[];
    version: number;
    retryPolicy: RetryPolicy;
    createReq: CreatePromiseReq;
    constructor(id: string, func: Func, args: any[], version: number, retryPolicy: RetryPolicy, createReq: CreatePromiseReq);
    [Symbol.iterator](): Generator<LFC<T>, T, any>;
}
export declare class RFI<T> implements Iterable<RFI<T>> {
    id: string;
    func: string;
    version: number;
    createReq: CreatePromiseReq;
    mode: "attached" | "detached";
    constructor(id: string, func: string, version: number, createReq: CreatePromiseReq, mode?: "attached" | "detached");
    [Symbol.iterator](): Generator<RFI<T>, Future<T>, any>;
}
export declare class RFC<T> implements Iterable<RFC<T>> {
    id: string;
    func: string;
    version: number;
    createReq: CreatePromiseReq;
    mode: "attached";
    constructor(id: string, func: string, version: number, createReq: CreatePromiseReq);
    [Symbol.iterator](): Generator<RFC<T>, T, any>;
}
export declare class DIE implements Iterable<DIE> {
    condition: boolean;
    error: ResonateError;
    constructor(condition: boolean, error: ResonateError);
    [Symbol.iterator](): Generator<DIE, void, any>;
}
export declare class Future<T> implements Iterable<Future<T>> {
    id: string;
    private readonly value?;
    readonly state: "pending" | "completed";
    private mode;
    constructor(id: string, state: "pending" | "completed", value?: Result<T>, mode?: "attached" | "detached");
    getValue(): T;
    [Symbol.iterator](): Generator<Future<T>, T, undefined>;
}
export interface Context {
    readonly id: string;
    readonly parentId: string;
    readonly rootId: string;
    readonly info: {
        readonly attempt: number;
        readonly timeout: number;
        readonly version: number;
    };
    lfi<F extends Func>(func: F, ...args: ParamsWithOptions<F>): LFI<Return<F>>;
    lfi<T>(func: string, ...args: any[]): LFI<T>;
    lfc<F extends Func>(func: F, ...args: ParamsWithOptions<F>): LFC<Return<F>>;
    lfc<T>(func: string, ...args: any[]): LFC<T>;
    rfi<F extends Func>(func: F, ...args: ParamsWithOptions<F>): RFI<Return<F>>;
    rfi<T>(func: string, ...args: any[]): RFI<T>;
    rfc<F extends Func>(func: F, ...args: ParamsWithOptions<F>): RFC<Return<F>>;
    rfc<T>(func: string, ...args: any[]): RFC<T>;
    beginRun<F extends Func>(func: F, ...args: ParamsWithOptions<F>): LFI<Return<F>>;
    beginRun<T>(func: string, ...args: any[]): LFI<T>;
    run<F extends Func>(func: F, ...args: ParamsWithOptions<F>): LFC<Return<F>>;
    run<T>(func: string, ...args: any[]): LFC<T>;
    beginRpc<F extends Func>(func: F, ...args: ParamsWithOptions<F>): RFI<Return<F>>;
    beginRpc<T>(func: string, ...args: any[]): RFI<T>;
    rpc<F extends Func>(func: F, ...args: ParamsWithOptions<F>): RFC<Return<F>>;
    rpc<T>(func: string, ...args: any[]): RFC<T>;
    detached<F extends Func>(func: F, ...args: ParamsWithOptions<F>): RFI<Return<F>>;
    detached<T>(func: string, ...args: any[]): RFI<T>;
    sleep(ms: number): RFC<void>;
    sleep(opts: {
        for?: number;
        until?: Date;
    }): RFC<void>;
    sleep(msOrOpts: number | {
        for?: number;
        until?: Date;
    }): RFC<void>;
    promise<T>(): RFI<T>;
    promise<T>({ id, timeout, data, tags, }: {
        id?: string;
        timeout?: number;
        data?: any;
        tags?: Record<string, string>;
    }): RFI<T>;
    panic(condition: boolean, msg?: string): DIE;
    assert(condition: boolean, msg?: string): DIE;
    getDependency<T = any>(key: string): T | undefined;
    options(opts?: Partial<Options>): Options;
    date: ResonateDate;
    math: ResonateMath;
}
export interface ResonateDate {
    now(): LFC<number>;
}
export interface ResonateMath {
    random(): LFC<number>;
}
export declare class InnerContext implements Context {
    readonly id: string;
    readonly info: {
        attempt: number;
        readonly timeout: number;
        readonly version: number;
    };
    readonly func: string;
    readonly retryPolicy: RetryPolicy;
    readonly rootId: string;
    readonly parentId: string;
    readonly clock: Clock;
    readonly span: Span;
    private registry;
    private dependencies;
    private optsBuilder;
    private seq;
    run: {
        <F extends Func>(func: F, ...args: ParamsWithOptions<F>): LFC<Return<F>>;
        <T>(func: string, ...args: any[]): LFC<T>;
    };
    rpc: {
        <F extends Func>(func: F, ...args: ParamsWithOptions<F>): RFC<Return<F>>;
        <T>(func: string, ...args: any[]): RFC<T>;
    };
    beginRun: {
        <F extends Func>(func: F, ...args: ParamsWithOptions<F>): LFI<Return<F>>;
        <T>(func: string, ...args: any[]): LFI<T>;
    };
    beginRpc: {
        <F extends Func>(func: F, ...args: ParamsWithOptions<F>): RFI<Return<F>>;
        <T>(func: string, ...args: any[]): RFI<T>;
    };
    constructor({ id, rId, pId, func, clock, registry, dependencies, optsBuilder, timeout, version, retryPolicy, span, }: {
        id: string;
        rId?: string;
        pId?: string;
        func: string;
        clock: Clock;
        registry: Registry;
        dependencies: Map<string, any>;
        optsBuilder: OptionsBuilder;
        timeout: number;
        version: number;
        retryPolicy: RetryPolicy;
        span: Span;
    });
    child({ id, func, timeout, version, retryPolicy, span, }: {
        id: string;
        func: string;
        timeout: number;
        version: number;
        retryPolicy: RetryPolicy;
        span: Span;
    }): InnerContext;
    lfi<F extends Func>(func: F, ...args: ParamsWithOptions<F>): LFI<Return<F>>;
    lfi<T>(func: string, ...args: any[]): LFI<T>;
    lfc<F extends Func>(func: F, ...args: ParamsWithOptions<F>): LFC<Return<F>>;
    lfc<T>(func: string, ...args: any[]): LFC<T>;
    rfi<F extends Func>(func: F, ...args: ParamsWithOptions<F>): RFI<Return<F>>;
    rfi<T>(func: string, ...args: any[]): RFI<T>;
    rfc<F extends Func>(func: F, ...args: ParamsWithOptions<F>): RFC<Return<F>>;
    rfc<T>(func: string, ...args: any[]): RFC<T>;
    detached<F extends Func>(func: F, ...args: ParamsWithOptions<F>): RFI<Return<F>>;
    detached<T>(func: string, ...args: any[]): RFI<T>;
    promise<T>({ id, timeout, data, tags, }?: {
        id?: string;
        timeout?: number;
        data?: any;
        tags?: Record<string, string>;
    }): RFI<T>;
    sleep(msOrOpts: number | {
        for?: number;
        until?: Date;
    }): RFC<void>;
    panic(condition: boolean, msg?: string): DIE;
    assert(condition: boolean, msg?: string): DIE;
    getDependency<T = any>(name: string): T | undefined;
    options(opts?: Partial<Pick<Options, "id" | "tags" | "target" | "timeout" | "version" | "retryPolicy">>): Options;
    readonly date: {
        now: () => LFC<number>;
    };
    readonly math: {
        random: () => LFC<number>;
    };
    localCreateReq(id: string, data: any, opts: Options): CreatePromiseReq;
    remoteCreateReq(id: string, data: any, opts: Options, maxTimeout?: number): CreatePromiseReq;
    latentCreateOpts(id: string, timeout?: number, data?: any, tags?: Record<string, string>): CreatePromiseReq;
    sleepCreateOpts(id: string, time: number): CreatePromiseReq;
    seqid(): string;
}
//# sourceMappingURL=context.d.ts.map