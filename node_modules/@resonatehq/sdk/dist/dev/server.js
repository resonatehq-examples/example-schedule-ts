"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
const cron_parser_1 = require("cron-parser");
const exceptions_1 = __importDefault(require("../src/exceptions"));
const util = __importStar(require("../src/util"));
class TagRouter {
    tag;
    constructor(tag = "resonate:invoke") {
        this.tag = tag;
    }
    route(promise) {
        return promise.tags?.[this.tag];
    }
}
class Server {
    promises;
    tasks;
    schedules;
    routers;
    targets;
    constructor() {
        this.promises = new Map();
        this.tasks = new Map();
        this.schedules = new Map();
        this.routers = new Array(new TagRouter());
        this.targets = { default: "local://any@default" };
    }
    next(time) {
        let timeout;
        // Check promises
        for (const promise of this.promises.values()) {
            if (promise.state === "pending") {
                timeout = Math.min(promise.timeout, timeout ?? promise.timeout);
            }
        }
        // Check schedules
        for (const schedule of this.schedules.values()) {
            util.assertDefined(schedule.nextRunTime);
            timeout = Math.min(schedule.nextRunTime, timeout ?? schedule.nextRunTime);
        }
        // Check tasks
        for (const task of this.tasks.values()) {
            if (["init", "claimed", "enqueued"].includes(task.state)) {
                timeout = Math.min(task.expiry, timeout ?? task.expiry);
            }
        }
        // Convert to delay relative to `time`, clamped to signed 32-bit range
        return timeout !== undefined ? Math.min(Math.max(0, timeout - time), 2147483647) : timeout;
    }
    step(time) {
        for (const schedule of this.schedules.values()) {
            util.assertDefined(schedule.nextRunTime);
            if (time < schedule.nextRunTime) {
                continue;
            }
            try {
                this.createPromise({
                    id: schedule.promiseId.replace("{{.timestamp}}", time.toString()),
                    timeout: time + schedule.promiseTimeout,
                    param: schedule.promiseParam,
                    tags: schedule.promiseTags,
                    strict: false,
                    time,
                });
            }
            catch { }
            const { applied } = this.transitionSchedule({ id: schedule.id, to: "created", updating: true, time });
            util.assert(applied, `step(): failed to transition schedule '${schedule.id}' to 'created' state`);
        }
        // Reject timed-out promises
        for (const promise of this.promises.values()) {
            if (promise.state === "pending" && time >= promise.timeout) {
                const { applied } = this.transitionPromise({ id: promise.id, to: "rejected_timedout", time });
                util.assert(applied, `step(): promise '${promise.id}' expected to be timed out but transition did not apply`);
            }
        }
        // Transition expired tasks back to init
        for (const task of this.tasks.values()) {
            if (["enqueued", "claimed"].includes(task.state)) {
                util.assertDefined(task.expiry);
                if (time >= task.expiry) {
                    const { applied } = this.transitionTask({ id: task.id, to: "init", force: true, time });
                    util.assert(applied, `step(): failed to force-reinit expired task '${task.id}'`);
                }
            }
        }
        const inFlightRootPromiseIds = new Set();
        for (const task of this.tasks.values()) {
            if (["enqueued", "claimed"].includes(task.state)) {
                inFlightRootPromiseIds.add(task.rootPromiseId);
            }
        }
        const msgs = [];
        for (const task of this.tasks.values()) {
            if (task.state !== "init" || task.expiry > time || inFlightRootPromiseIds.has(task.rootPromiseId)) {
                continue;
            }
            let msg;
            if (task.type === "invoke") {
                msg = {
                    msg: {
                        type: "invoke",
                        task: {
                            ...task,
                            timeout: this.getPromise({ id: task.rootPromiseId }).timeout,
                        },
                        headers: {},
                    },
                    recv: task.recv,
                };
            }
            else if (task.type === "resume") {
                msg = {
                    msg: {
                        type: "resume",
                        task: {
                            ...task,
                            timeout: this.getPromise({ id: task.rootPromiseId }).timeout,
                        },
                        headers: {},
                    },
                    recv: task.recv,
                };
            }
            else {
                util.assert(task.type === "notify", `step(): unexpected task type '${task.type}' for notify message`);
                msg = {
                    msg: {
                        type: "notify",
                        promise: this.getPromise({ id: task.rootPromiseId }),
                        headers: {},
                    },
                    recv: task.recv,
                };
            }
            msgs.push(msg);
            if (task.type === "notify") {
                const { applied } = this.transitionTask({ id: task.id, to: "completed", time });
                util.assert(applied, `step(): failed to complete notify task '${task.id}'`);
            }
            else {
                const { applied } = this.transitionTask({ id: task.id, to: "enqueued", time });
                util.assert(applied, `step(): failed to enqueue task '${task.id}' after invoking/resuming`);
            }
            inFlightRootPromiseIds.add(task.rootPromiseId);
        }
        return msgs;
    }
    process(requ, time) {
        switch (requ.kind) {
            case "createPromise": {
                return {
                    kind: requ.kind,
                    promise: this.createPromise({
                        ...requ,
                        time,
                    }),
                };
            }
            case "createPromiseAndTask": {
                const { promise, task } = this.createPromiseAndTask({
                    id: requ.promise.id,
                    timeout: requ.promise.timeout,
                    processId: requ.task.processId,
                    ttl: requ.task.ttl,
                    param: requ.promise.param,
                    tags: requ.promise.tags,
                    iKey: requ.iKey,
                    strict: requ.strict,
                    time,
                });
                return {
                    kind: requ.kind,
                    promise: promise,
                    task: task,
                };
            }
            case "readPromise": {
                return {
                    kind: requ.kind,
                    promise: this.readPromise({ ...requ }),
                };
            }
            case "completePromise": {
                return {
                    kind: requ.kind,
                    promise: this.completePromise({
                        ...requ,
                        time,
                    }),
                };
            }
            case "createCallback": {
                return {
                    kind: requ.kind,
                    ...this.createCallback({
                        ...requ,
                        time,
                    }),
                };
            }
            case "createSubscription": {
                return {
                    kind: requ.kind,
                    ...this.createSubscription({ ...requ, time }),
                };
            }
            case "createSchedule": {
                return {
                    kind: requ.kind,
                    schedule: this.createSchedule({
                        id: requ.id,
                        cron: requ.cron,
                        promiseId: requ.promiseId,
                        promiseTimeout: requ.promiseTimeout,
                        iKey: requ.iKey,
                        description: requ.description,
                        tags: requ.tags,
                        promiseParam: requ.promiseParam,
                        promiseTags: requ.promiseTags,
                        time,
                    }),
                };
            }
            case "readSchedule": {
                return { kind: requ.kind, schedule: this.readSchedule({ ...requ }) };
            }
            case "deleteSchedule": {
                this.deleteSchedule({ ...requ, time });
                return { kind: requ.kind };
            }
            case "claimTask": {
                return {
                    kind: "claimTask",
                    message: this.claimTask({
                        ...requ,
                        time,
                    }),
                };
            }
            case "completeTask": {
                return {
                    kind: "completeTask",
                    task: this.completeTask({ ...requ, time }),
                };
            }
            case "heartbeatTasks": {
                return {
                    kind: "heartbeatTasks",
                    tasksAffected: this.heartbeatTasks({ ...requ, time }),
                };
            }
            case "dropTask": {
                this.dropTask({ ...requ, time });
                return { kind: "dropTask" };
            }
            case "searchPromises": {
                return { kind: "searchPromises", promises: this.searchPromises({ ...requ }) };
            }
            case "searchSchedules": {
                return { kind: "searchSchedules", schedules: this.searchSchedules({ ...requ }) };
            }
        }
    }
    createPromise({ id, timeout, param, tags, iKey, strict, time, }) {
        return this._createPromise({
            id,
            timeout,
            param,
            tags,
            iKey,
            strict,
            time,
        }).promise;
    }
    createPromiseAndTask({ id, timeout, processId, ttl, param, tags, iKey, strict, time, }) {
        const { promise, task } = this._createPromise({
            id,
            timeout,
            processId,
            ttl,
            param,
            tags,
            iKey,
            strict,
            time,
        });
        if (task === undefined) {
            return { promise };
        }
        return { promise, task: { ...task, timeout: promise.timeout } };
    }
    _createPromise({ id, timeout, param, tags, iKey, strict, processId, ttl, time, }) {
        const { promise, task, applied } = this.transitionPromise({
            id,
            to: "pending",
            strict,
            timeout,
            iKey,
            value: param,
            tags,
            time,
        });
        util.assert(!applied || ["pending", "rejected_timedout"].includes(promise.state), `createPromise: unexpected promise state '${promise.state}' after transition to 'pending' for promise '${id}'`);
        if (applied && task !== undefined && processId !== undefined) {
            const { task: newTask, applied: appliedTask } = this.transitionTask({
                id: task.id,
                to: "claimed",
                counter: 1,
                processId,
                ttl,
                time,
            });
            util.assert(appliedTask, `createPromise: failed to claim task '${task.id}' for subsequent processing`);
            return { promise: promise, task: newTask };
        }
        return { promise, task };
    }
    readPromise({ id }) {
        return this.getPromise({ id });
    }
    completePromise({ id, state, value, iKey, strict, time, }) {
        const { promise, applied } = this.transitionPromise({
            id,
            to: state,
            strict,
            iKey,
            value,
            time,
        });
        util.assert(!applied || [state, "rejected_timedout"].includes(promise.state), `completePromise: after transition to '${state}', promise '${id}' is in unexpected state '${promise.state}'`);
        return promise;
    }
    createSubscription({ id, promiseId, timeout, recv, time, }) {
        {
            const record = this.promises.get(promiseId);
            if (!record) {
                throw exceptions_1.default.SERVER_ERROR("Promise not found");
            }
            const cbId = `__notify:${promiseId}:${id}`;
            if (record.state !== "pending" || record.callbacks?.has(cbId)) {
                return { promise: record, callback: undefined };
            }
            const callback = {
                id: cbId,
                type: "notify",
                promiseId: promiseId,
                rootPromiseId: promiseId,
                recv,
                timeout,
                createdOn: time,
            };
            if (!record.callbacks) {
                record.callbacks = new Map();
            }
            // register and return
            record.callbacks.set(cbId, callback);
            return {
                promise: record,
                callback: callback,
            };
        }
    }
    createCallback({ promiseId, rootPromiseId, timeout, recv, time, }) {
        const record = this.promises.get(promiseId);
        if (!record) {
            throw exceptions_1.default.SERVER_ERROR("Promise not found");
        }
        if (record.state !== "pending" || record.callbacks?.has(promiseId)) {
            return { promise: record, callback: undefined };
        }
        const callback = {
            id: `__resume:${rootPromiseId}:${promiseId}`,
            type: "resume",
            promiseId,
            rootPromiseId,
            recv,
            timeout,
            createdOn: time,
        };
        if (!record.callbacks) {
            record.callbacks = new Map();
        }
        record.callbacks.set(callback.id, callback);
        return { promise: record, callback: callback };
    }
    claimTask({ id, counter, processId, ttl, time, }) {
        const { task, applied } = this.transitionTask({
            id,
            to: "claimed",
            counter,
            processId,
            ttl,
            time,
        });
        util.assert(applied, `claimTask: failed to claim task '${id}' with counter ${counter} using processId '${processId}'`);
        switch (task.type) {
            case "invoke": {
                const promise = this.getPromise({ id: task.rootPromiseId });
                return {
                    kind: task.type,
                    promises: {
                        root: { id: promise.id, data: promise },
                    },
                };
            }
            case "resume": {
                return {
                    kind: task.type,
                    promises: {
                        root: {
                            id: task.rootPromiseId,
                            data: this.getPromise({ id: task.rootPromiseId }),
                        },
                        leaf: {
                            id: task.leafPromiseId,
                            data: this.getPromise({ id: task.leafPromiseId }),
                        },
                    },
                };
            }
            case "notify":
                throw exceptions_1.default.SERVER_ERROR(`Unexpected task type '${task.type}' notify`);
        }
    }
    completeTask({ id, counter, time }) {
        const { task } = this.transitionTask({ id, to: "completed", counter, time });
        return task;
    }
    dropTask({ id, counter, time }) {
        const { applied } = this.transitionTask({ id, to: "init", counter, time });
        util.assert(applied);
        return;
    }
    searchPromises({ id }) {
        return Array.from(this.promises.values());
    }
    searchSchedules({ id }) {
        return Array.from(this.schedules.values());
    }
    heartbeatTasks({ processId, time }) {
        let affectedTasks = 0;
        for (const task of this.tasks.values()) {
            if (task.state !== "claimed" || task.processId !== processId) {
                continue;
            }
            const { applied } = this.transitionTask({ id: task.id, to: "claimed", force: true, time });
            util.assert(applied, `heartbeatTasks: failed to refresh heartbeat for task '${task.id}' owned by process '${processId}'`);
            affectedTasks += 1;
        }
        return affectedTasks;
    }
    createSchedule({ id, cron, promiseId, promiseTimeout, iKey, description, tags, promiseParam, promiseTags, time, }) {
        return this.transitionSchedule({
            id,
            to: "created",
            cron,
            promiseId,
            promiseTimeout,
            iKey,
            description,
            tags,
            promiseParam,
            promiseTags,
            time,
        }).schedule;
    }
    readSchedule({ id }) {
        const schedule = this.schedules.get(id);
        if (schedule === undefined) {
            throw exceptions_1.default.SERVER_ERROR("Schedule not found");
        }
        return schedule;
    }
    deleteSchedule({ id, time }) {
        const { applied } = this.transitionSchedule({ id, to: "deleted", time });
        util.assert(applied, `deleteSchedule: failed to delete schedule '${id}'`);
    }
    getPromise({ id }) {
        const record = this.promises.get(id);
        if (!record) {
            throw exceptions_1.default.SERVER_ERROR("Promise not found");
        }
        return record;
    }
    transitionPromise({ id, to, strict, timeout, iKey, value, tags, time, }) {
        const { promise, applied } = this._transitionPromise({
            id,
            to,
            strict,
            timeout,
            iKey,
            value,
            tags,
            time,
        });
        // Initialize invocation tasks on pending
        if (applied && promise.state === "pending") {
            for (const router of this.routers) {
                const recv = router.route(promise);
                if (recv !== undefined) {
                    const { task, applied } = this.transitionTask({
                        id: `__invoke:${id}`,
                        to: "init",
                        type: "invoke",
                        recv: this.targets[recv] ?? recv,
                        rootPromiseId: promise.id,
                        leafPromiseId: promise.id,
                        timeout: promise.timeout,
                        time,
                    });
                    util.assert(applied, `transitionPromise: failed to init invoke task for promise '${id}' on route '${recv}'`);
                    return { promise, task, applied };
                }
            }
        }
        // Complete any tasks and schedule callbacks after resolution
        if (applied && ["resolved", "rejected", "rejected_canceled", "rejected_timedout"].includes(promise.state)) {
            // Mark existing tasks as completed
            for (const task of this.tasks.values()) {
                if (task.rootPromiseId === id && ["init", "enqueued", "claimed"].includes(task.state)) {
                    const { applied } = this.transitionTask({
                        id: task.id,
                        to: "completed",
                        force: true,
                        time,
                    });
                    util.assert(applied, `transitionPromise: failed to complete task '${task.id}' for promise '${id}'`);
                }
            }
            // Initialize callback tasks
            if (promise.callbacks) {
                for (const callback of promise.callbacks.values()) {
                    const { applied } = this.transitionTask({
                        ...callback,
                        to: "init",
                        leafPromiseId: callback.promiseId,
                        time,
                    });
                    util.assert(applied, `transitionPromise: failed to init callback task '${callback.id}' for promise '${id}'`);
                }
                promise.callbacks.clear();
            }
        }
        return { promise, applied };
    }
    _transitionPromise({ id, to, strict, timeout, iKey, value, tags, time, }) {
        let record = this.promises.get(id);
        // Create new promise
        if (record === undefined && to === "pending") {
            util.assertDefined(timeout);
            record = {
                id,
                state: to,
                timeout,
                iKeyForCreate: iKey,
                param: value,
                value: undefined,
                tags: tags ?? {},
                createdOn: time,
            };
            this.promises.set(id, record);
            return { promise: record, applied: true };
        }
        // Cannot complete non-existent promise
        if (record === undefined && ["resolved", "rejected", "rejected_canceled"].includes(to)) {
            throw exceptions_1.default.SERVER_ERROR("Promise not found");
        }
        // No-op re-create pending if before timeout and same iKey
        if (record?.state === "pending" &&
            to === "pending" &&
            time < record.timeout &&
            ikeyMatch(record.iKeyForCreate, iKey)) {
            return { promise: record, applied: false };
        }
        // Auto-timeout transition
        if (record?.state === "pending" &&
            to === "pending" &&
            !strict &&
            time >= record.timeout &&
            ikeyMatch(record.iKeyForCreate, iKey)) {
            return this._transitionPromise({ id, to: "rejected_timedout", time });
        }
        // Resolve or reject before timeout
        if (record?.state === "pending" &&
            ["resolved", "rejected", "rejected_canceled"].includes(to) &&
            time < record.timeout) {
            record = {
                ...record,
                state: to,
                iKeyForComplete: iKey,
                value: value,
                completedOn: time,
            };
            this.promises.set(id, record);
            return { promise: record, applied: true };
        }
        // Attempt completion after timeout without strict -> treat as timeout
        if (record?.state === "pending" &&
            ["resolved", "rejected", "rejected_canceled"].includes(to) &&
            !strict &&
            time >= record.timeout) {
            return this._transitionPromise({ id, to: "rejected_timedout", time });
        }
        // Strict completion after timeout -> error
        if (record?.state === "pending" &&
            ["resolved", "rejected", "rejected_canceled"].includes(to) &&
            strict &&
            time >= record.timeout) {
            throw exceptions_1.default.SERVER_ERROR("Promise already timedout");
        }
        // Transition to timed-out
        if (record?.state === "pending" && to === "rejected_timedout") {
            util.assert(time >= record.timeout, `transitionPromise(rejected_timedout): cannot time out promise '${id}' before its timeout (${record.timeout})`);
            record = {
                ...record,
                state: record.tags?.["resonate:timeout"] === "true" ? "resolved" : to,
            };
            this.promises.set(id, record);
            return { promise: record, applied: true };
        }
        // No-op re-pending or re-completing without strict and matching iKey
        if (record?.state !== undefined &&
            ["resolved", "rejected", "rejected_canceled", "rejected_timedout"].includes(record.state) &&
            to === "pending" &&
            !strict &&
            ikeyMatch(record.iKeyForCreate, iKey)) {
            return { promise: record, applied: false };
        }
        if (record !== undefined &&
            ["resolved", "rejected", "rejected_canceled"].includes(record.state) &&
            ["resolved", "rejected", "rejected_canceled"].includes(to) &&
            !strict &&
            ikeyMatch(record.iKeyForComplete, iKey)) {
            return { promise: record, applied: false };
        }
        if (record?.state === "rejected_timedout" &&
            ["resolved", "rejected", "rejected_canceled"].includes(to) &&
            !strict) {
            return { promise: record, applied: false };
        }
        if (record !== undefined &&
            ["resolved", "rejected", "rejected_canceled"].includes(record.state) &&
            ["resolved", "rejected", "rejected_canceled"].includes(to) &&
            strict &&
            ikeyMatch(record.iKeyForComplete, iKey) &&
            record.state === to) {
            return { promise: record, applied: false };
        }
        // Fallback
        throw exceptions_1.default.SERVER_ERROR("Unexpected promise transition");
    }
    transitionTask({ id, to, type, recv, timeout, rootPromiseId, leafPromiseId, counter, processId, ttl, force, time, }) {
        let record = this.tasks.get(id);
        if (record === undefined && to === "init") {
            util.assertDefined(type);
            util.assertDefined(recv);
            util.assertDefined(rootPromiseId);
            util.assertDefined(leafPromiseId);
            util.assertDefined(timeout);
            record = {
                id,
                counter: 1,
                timeout,
                state: to,
                type,
                recv,
                rootPromiseId,
                leafPromiseId,
                expiry: 0,
                createdOn: time,
            };
            this.tasks.set(id, record);
            return { task: record, applied: true };
        }
        if (record?.state === "init" && to === "enqueued") {
            record = {
                ...record,
                state: to,
                expiry: time + 5000, // wait 5s before transitioning back to init if unclaimed
            };
            this.tasks.set(id, record);
            return { task: record, applied: true };
        }
        if (record?.state === "init" && to === "claimed" && record.counter === counter) {
            util.assertDefined(processId);
            util.assertDefined(ttl);
            util.assertDefined(counter);
            record = {
                ...record,
                state: to,
                processId,
                ttl,
                expiry: time + ttl,
            };
            this.tasks.set(id, record);
            return { task: record, applied: true };
        }
        if (record?.state === "enqueued" && to === "claimed" && record.counter === counter) {
            util.assertDefined(ttl);
            util.assertDefined(counter);
            util.assertDefined(processId);
            record = {
                ...record,
                state: to,
                processId,
                ttl,
                expiry: time + ttl,
            };
            this.tasks.set(id, record);
            return { task: record, applied: true };
        }
        if (record !== undefined &&
            ["init", "enqueued"].includes(record.state) &&
            record.type === "notify" &&
            to === "completed") {
            record = {
                ...record,
                state: to,
                completedOn: time,
            };
            this.tasks.set(id, record);
            return { task: record, applied: true };
        }
        if (record !== undefined && record.state === "claimed" && record.counter === counter && to === "init") {
            record = {
                ...record,
                counter: record.counter + 1,
                state: to,
                processId: undefined,
                ttl: undefined,
                expiry: time + 5000, // wait 5s before sending again
            };
            this.tasks.set(id, record);
            return { task: record, applied: true };
        }
        if (record !== undefined && ["enqueued", "claimed"].includes(record.state) && to === "init") {
            util.assertDefined(record.expiry);
            record = {
                ...record,
                counter: record.counter + 1,
                state: to,
                processId: undefined,
                ttl: undefined,
                expiry: 0,
            };
            this.tasks.set(id, record);
            return { task: record, applied: true };
        }
        if (record?.state === "claimed" && to === "claimed" && force) {
            util.assertDefined(record.ttl);
            record = {
                ...record,
                expiry: time + record.ttl,
            };
            this.tasks.set(id, record);
            return { task: record, applied: true };
        }
        if (record?.state === "claimed" &&
            to === "completed" &&
            record.counter === counter &&
            record.expiry !== undefined &&
            record.expiry >= time) {
            record = {
                ...record,
                state: to,
                completedOn: time,
            };
            this.tasks.set(id, record);
            return { task: record, applied: true };
        }
        if (record !== undefined &&
            ["init", "enqueued", "claimed"].includes(record?.state) &&
            to === "completed" &&
            force) {
            record = {
                ...record,
                state: to,
                completedOn: time,
            };
            this.tasks.set(id, record);
            return { task: record, applied: true };
        }
        if (record?.state === "completed" && to === "completed") {
            return { task: record, applied: false };
        }
        if (record === undefined) {
            throw exceptions_1.default.SERVER_ERROR("Task not found");
        }
        throw exceptions_1.default.SERVER_ERROR("Task is already claimed, completed, or an invalid counter was provided");
    }
    transitionSchedule({ id, to, cron, promiseId, promiseTimeout, iKey, description, tags, promiseParam, promiseTags, updating, time, }) {
        let record = this.schedules.get(id);
        // Create new schedule
        if (record === undefined && to === "created") {
            util.assertDefined(cron);
            util.assertDefined(promiseId);
            util.assertDefined(promiseTimeout);
            util.assert(promiseTimeout >= 0, "promiseTimeout must be non-negative");
            record = {
                id,
                description,
                cron,
                tags: tags ?? {},
                promiseId,
                promiseTimeout,
                promiseParam,
                promiseTags: promiseTags ?? {},
                nextRunTime: cron_parser_1.CronExpressionParser.parse(cron, { currentDate: time }).next().getTime(),
                iKey,
                createdOn: time,
                lastRunTime: 0,
            };
            this.schedules.set(id, record);
            return { schedule: record, applied: true };
        }
        // No-op if same iKey
        if (record !== undefined && to === "created" && ikeyMatch(iKey, record.iKey)) {
            return { schedule: record, applied: false };
        }
        // Update existing schedule
        if (record !== undefined && to === "created" && updating) {
            const nextRunTime = cron_parser_1.CronExpressionParser.parse(record.cron, { currentDate: time }).next().getTime();
            record = {
                ...record,
                lastRunTime: record.nextRunTime,
                nextRunTime: nextRunTime,
            };
            this.schedules.set(id, record);
            return { schedule: record, applied: true };
        }
        // Schedule exists and not updating
        if (record !== undefined && to === "created") {
            throw exceptions_1.default.SERVER_ERROR("Schedule already exists");
        }
        // Delete non-existent
        if (record === undefined && to === "deleted") {
            throw exceptions_1.default.SERVER_ERROR("Schedule not found");
        }
        // Delete existing
        if (record !== undefined && to === "deleted") {
            this.schedules.delete(id);
            return { schedule: record, applied: true };
        }
        // Fallback error
        throw exceptions_1.default.SERVER_ERROR("Unexpected schedule transition");
    }
}
exports.Server = Server;
function ikeyMatch(left, right) {
    return left !== undefined && right !== undefined && left === right;
}
//# sourceMappingURL=server.js.map